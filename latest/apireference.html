<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="apimanual.html">Manual</a></li><li class="current"><a class="toctext" href="apireference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#Attributes-1">Attributes</a></li><li><a class="toctext" href="#Solver-1">Solver</a></li><li><a class="toctext" href="#SolverInstance-1">SolverInstance</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Objectives-1">Objectives</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><p>[Some introduction to API. List basic standalone methods.]</p><h2><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h2><p>List of attribute categories.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverAttribute" href="#MathOptInterface.AbstractSolverAttribute"><code>MathOptInterface.AbstractSolverAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverInstanceAttribute" href="#MathOptInterface.AbstractSolverInstanceAttribute"><code>MathOptInterface.AbstractSolverInstanceAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverInstanceAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L10-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractVariableAttribute" href="#MathOptInterface.AbstractVariableAttribute"><code>MathOptInterface.AbstractVariableAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractVariableAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L17-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractConstraintAttribute" href="#MathOptInterface.AbstractConstraintAttribute"><code>MathOptInterface.AbstractConstraintAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractConstraintAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L24-L28">source</a><br/></section><p>Functions for getting and setting attributes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cangetattribute" href="#MathOptInterface.cangetattribute"><code>MathOptInterface.cangetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cangetattribute(s::AbstractSolver, attr::AbstractSolverAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to query attribute <code>attr</code> from the solver <code>s</code>.</p><pre><code class="language-none">cangetattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, R::Type{VariableReference})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{VariablewiseConstraintReference{T})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{AffineConstraintReference{T})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{QuadraticConstraintReference{T})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the solver instance <code>m</code> currently has a value for the attributed specified by attribute type <code>attr</code> applied to the reference type <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">cangetattribute(GurobiSolver(), SupportsAffineConstraint{Zero}())
cangetattribute(m, ObjectiveValue())
cangetattribute(m, VariablePrimalStart(), varref)
cangetattribute(m, ConstraintPrimal(), conref)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L86-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getattribute" href="#MathOptInterface.getattribute"><code>MathOptInterface.getattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute(s::AbstractSolver, attr::AbstractSolverAttribute)</code></pre><p>Return an attribute <code>attr</code> of the solver <code>s</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractSolverInstanceAttribute)</code></pre><p>Return an attribute <code>attr</code> of the solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::VariableReference)</code></pre><p>Return an attribute <code>attr</code> of the variable <code>v</code> in solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::Vector{VariableReference})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::ConstraintReference)</code></pre><p>Return an attribute <code>attr</code> of the constraint <code>c</code> in solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{VariablewiseConstraintReference{T}})
getattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{AffineConstraintReference{T}})
getattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{QuadraticConstraintReference{T}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the solver instance <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">getattribute(m, ObjectiveValue())
getattribute(m, VariableResult(), ref)
getattribute(m, VariableResult(5), [ref1, ref2])
getattribute(m, OtherAttribute(&quot;something specific to cplex&quot;))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L33-L68">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getattribute!" href="#MathOptInterface.getattribute!"><code>MathOptInterface.getattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute!(output, m::AbstractSolverInstance, args...)</code></pre><p>An in-place version of <code>getattribute</code>. The signature matches that of <code>getattribute</code> except that the the result is placed in the vector <code>output</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L75-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cansetattribute" href="#MathOptInterface.cansetattribute"><code>MathOptInterface.cansetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cansetattribute(s::AbstractSolver, attr::AbstractSolverAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> in the solver <code>s</code>.</p><pre><code class="language-none">cansetattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, R::Type{VariableReference})::Bool
cansetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{VariablewiseConstraintReference{T})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{AffineConstraintReference{T})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{QuadraticConstraintReference{T})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> applied to the reference type <code>R</code> in the solver instance <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">cansetattribute(GurobiSolver(), SupportsAffineConstraint{Zero}())
cansetattribute(m, ObjectiveValue())
cansetattribute(m, VariablePrimalStart(), VariableReference)
cansetattribute(m, ConstraintPrimal(), AffineConstraintReference{NonNegative})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L110-L130">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.setattribute!" href="#MathOptInterface.setattribute!"><code>MathOptInterface.setattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setattribute!(s::AbstractSolver, attr::AbstractSolverAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the solver <code>s</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractSolverInstanceAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::VariableReference, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::Vector{VariableReference}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::ConstraintReference, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{VariablewiseConstraintReference{T}})
setattribute!(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{AffineConstraintReference{T}})
setattribute!(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{QuadraticConstraintReference{T}})</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L134-L160">source</a><br/></section><h2><a class="nav-anchor" id="Solver-1" href="#Solver-1">Solver</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolver" href="#MathOptInterface.AbstractSolver"><code>MathOptInterface.AbstractSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolver</code></pre><p>Abstract supertype for &quot;solver&quot; objects. A solver is a lightweight object used for selecting solvers and parameters. It does not store any solver instance data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/MathOptInterface.jl#L3-L9">source</a><br/></section><p>List of solver attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ReturnsDuals" href="#MathOptInterface.ReturnsDuals"><code>MathOptInterface.ReturnsDuals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ReturnsDuals()</code></pre><p>A <code>Bool</code> indicating if the solver should be expected to return dual solutions when appropriate.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L168-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAddConstraintAfterSolve" href="#MathOptInterface.SupportsAddConstraintAfterSolve"><code>MathOptInterface.SupportsAddConstraintAfterSolve</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAddConstraintAfterSolve()</code></pre><p>A <code>Bool</code> indicating if the solver supports adding constraints after a solve. If <code>false</code>, then a new solver instance should be constructed instead.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L175-L180">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsDeleteConstraint" href="#MathOptInterface.SupportsDeleteConstraint"><code>MathOptInterface.SupportsDeleteConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsDeleteConstraint()</code></pre><p>A <code>Bool</code> indicating if the solver supports deleting constraints from a solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L183-L187">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAddVariableAfterSolve" href="#MathOptInterface.SupportsAddVariableAfterSolve"><code>MathOptInterface.SupportsAddVariableAfterSolve</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAddVariableAfterSolve()</code></pre><p>A <code>Bool</code> indicating if the solver supports adding variables after a solve. In the context of linear programming, this is known as column generation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L197-L202">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsQuadraticObjective" href="#MathOptInterface.SupportsQuadraticObjective"><code>MathOptInterface.SupportsQuadraticObjective</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsQuadraticObjective()</code></pre><p>A <code>Bool</code> indicating if the solver supports quadratic objectives.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L209-L213">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsConicThroughQuadratic" href="#MathOptInterface.SupportsConicThroughQuadratic"><code>MathOptInterface.SupportsConicThroughQuadratic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsConicThroughQuadratic()</code></pre><p>A <code>Bool</code> indicating if the solver interprets certain quadratic constraints as second-order cone constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L216-L220">source</a><br/></section><h2><a class="nav-anchor" id="SolverInstance-1" href="#SolverInstance-1">SolverInstance</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverInstance" href="#MathOptInterface.AbstractSolverInstance"><code>MathOptInterface.AbstractSolverInstance</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverInstance</code></pre><p>Abstract supertype which represents a solver&#39;s in-memory representation of an optimization problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/MathOptInterface.jl#L12-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolverInstance" href="#MathOptInterface.SolverInstance"><code>MathOptInterface.SolverInstance</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">SolverInstance(solver::AbstractSolver)</code></pre><p>Create a solver instance of <code>AbstractSolverInstance</code> using the given solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/MathOptInterface.jl#L19-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">optimize!(m::AbstractSolverInstance)</code></pre><p>Start the solution procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/MathOptInterface.jl#L26-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.freesolverinstance!" href="#MathOptInterface.freesolverinstance!"><code>MathOptInterface.freesolverinstance!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">freesolver instance!(m::AbstractSolverInstance)</code></pre><p>Release any resources and memory used by the solver instance. Note that the Julia garbage collector takes care of this automatically, but automatic collection cannot always be forced. This method is useful for more precise control of resources, especially in the case of commercial solvers with licensing restrictions on the number of concurrent runs. Users must discard the solver instance object after this method is invoked.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/MathOptInterface.jl#L33-L40">source</a><br/></section><p>List of solver instance attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RawSolver()</code></pre><p>An object that may be used to access a solver-specific API for this solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L288-L292">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Sense" href="#MathOptInterface.Sense"><code>MathOptInterface.Sense</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Sense()</code></pre><p>The optimization sense of the solver instance, an <code>OptimizationSense</code> with value <code>MinSense</code> or <code>MaxSense</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L257-L261">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfVariables()</code></pre><p>The number of variables in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L302-L306">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariablewiseConstraints" href="#MathOptInterface.NumberOfVariablewiseConstraints"><code>MathOptInterface.NumberOfVariablewiseConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfVariablewiseConstraints{T}()</code></pre><p>The number of variablewise constraints of type <code>T</code> in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L309-L313">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfAffineConstraints" href="#MathOptInterface.NumberOfAffineConstraints"><code>MathOptInterface.NumberOfAffineConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfAffineConstraints{T}()</code></pre><p>The number of affine constraints of type <code>T</code> in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L316-L320">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfQuadraticConstraints" href="#MathOptInterface.NumberOfQuadraticConstraints"><code>MathOptInterface.NumberOfQuadraticConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfQuadraticConstraints{T}()</code></pre><p>The number of quadratic constraints of type <code>T</code> in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L323-L327">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultCount()</code></pre><p>The number of results available.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L295-L299">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveValue(resultidx::Int=1, objectiveindex::Int=1)</code></pre><p>The objective value of the <code>resultindex</code>th primal result of the <code>objectiveindex</code>th objective.</p><p>Both <code>resultindex</code> and <code>objectiveindex</code> default to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L223-L229">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveBound()</code></pre><p>The best known bound on the optimal objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L236-L240">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RelativeGap()</code></pre><p>The final relative optimality gap, defined as <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L243-L247">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolveTime()</code></pre><p>The total elapsed solution time (in seconds) as reported by the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L250-L254">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SimplexIterations()</code></pre><p>The cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L266-L271">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BarrierIterations()</code></pre><p>The cumulative number of barrier iterations while solving a problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L274-L278">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NodeCount()</code></pre><p>The total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L281-L285">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatus()</code></pre><p>A <code>TerminationStatusCode</code> explaining why the solver stopped.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L420-L424">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PrimalStatus(N)
PrimalStatus()</code></pre><p>The <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L480-L486">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualStatus(N)
DualStatus()</code></pre><p>The <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L492-L498">source</a><br/></section><h3><a class="nav-anchor" id="Termination-Status-1" href="#Termination-Status-1">Termination Status</a></h3><p>The <code>TerminationStatus</code> attribute indicates why the solver stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the solver stopped executing.</p><p><strong>OK</strong></p><p>These are generally OK statuses.</p><ul><li><p><code>Success</code>: the algorithm ran successfully and has a result; this includes cases where the algorithm converges to an infeasible point (NLP) or converges to a solution of a homogeneous self-dual problem and has a certificate of primal/dual infeasibility</p></li><li><p><code>AlmostSuccess</code>: the algorithm <em>almost</em> ran successfully (e.g., to relaxed convergence tolerances) and has a result</p></li><li><p><code>InfeasibleNoResult</code>: the algorithm stopped because it decided that the problem is infeasible but does not have a result to return</p></li><li><p><code>UnboundedNoResult</code>: the algorithm stopped because it decided that the problem is unbounded but does not have a result to return</p></li><li><p><code>InfeasibleOrUnbounded</code>: the algorithm stopped because it decided that the problem is infeasible or unbounded (no result is available); this occasionally happens during MIP presolve</p></li></ul><p><strong>Limits</strong></p><p>The solver stopped because of some user-defined limit. To be documented: <code>IterationLimit</code>, <code>TimeLimit</code>, <code>NodeLimit</code>, <code>SolutionLimit</code>, <code>MemoryLimit</code>, <code>ObjectiveLimit</code>, <code>NormLimit</code>, <code>OtherLimit</code>.</p><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><p><code>SlowProgress</code>: the algorithm stopped because it was unable to continue making progress towards the solution</p></li><li><p><code>AlmostSuccess</code> should be used if there is additional information that relaxed convergence tolerances are satisfied</p></li></ul><p>To be documented: <code>NumericalError</code>, <code>InvalidSolverInstance</code>, <code>InvalidOption</code>, <code>Interrupted</code>, <code>OtherError</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L427-L457">source</a><br/></section><h3><a class="nav-anchor" id="Result-Status-1" href="#Result-Status-1">Result Status</a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes indicate how to interpret the result returned by the solver. The value of the attribute is of type <code>ResultStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><p><code>FeasiblePoint</code></p></li><li><p><code>NearlyFeasiblePoint</code></p></li><li><p><code>InfeasiblePoint</code></p></li><li><p><code>InfeasibilityCertificate</code></p></li><li><p><code>NearlyInfeasibilityCertificate</code></p></li><li><p><code>ReductionCertificate</code></p></li><li><p><code>NearlyReductionCertificate</code></p></li><li><p><code>Unknown</code></p></li><li><p><code>Other</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L462-L477">source</a><br/></section><h3><a class="nav-anchor" id="Basis-Status-1" href="#Basis-Status-1">Basis Status</a></h3><p>[what? BasisStatus]</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BasisStatusCode" href="#MathOptInterface.BasisStatusCode"><code>MathOptInterface.BasisStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>VariableBasisStatus</code> and <code>ConstraintBasisStatus</code> attribute. This explains the status of a given element with respect to an optimal solution basis. Possible values are:</p><ul><li><p><code>Basic</code>: element is in the basis</p></li><li><p><code>Nonbasic</code>: element is not in the basis</p></li><li><p><code>NonbasicAtLower</code>: element is not in the basis and is at its lower bound</p></li><li><p><code>NonbasicAtUpper</code>: element is not in the basis and is at its upper bound</p></li><li><p><code>SuperBasic</code>: element is not in the basis but is also not at one of its bounds</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L358-L369">source</a><br/></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>List of recognized sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSet" href="#MathOptInterface.AbstractSet"><code>MathOptInterface.AbstractSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSet</code></pre><p>Abstract supertype for set objects used to encode constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Reals" href="#MathOptInterface.Reals"><code>MathOptInterface.Reals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Reals(dim)</code></pre><p>The set <span>$\mathbb{R}^{dim}$</span> (containing all points) of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L17-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Zeros" href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zeros(dim)</code></pre><p>The set <span>$\{ 0 \}^{dim}$</span> (containing only the origin) of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L26-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NonNegatives" href="#MathOptInterface.NonNegatives"><code>MathOptInterface.NonNegatives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NonNegatives(dim)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dim} : x \ge 0 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L35-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NonPositives" href="#MathOptInterface.NonPositives"><code>MathOptInterface.NonPositives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NonPositives(dim)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^{dim} : x \le 0 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L44-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GreaterThan" href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GreaterThan(lower)</code></pre><p>The set <span>$[lower,\infty) \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L53-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LessThan" href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LessThan(upper)</code></pre><p>The set <span>$(-\infty,upper] \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L62-L66">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Interval" href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Interval(lower,upper)</code></pre><p>The interval <span>$[lower, upper] \subseteq \mathbb{R}$</span>. If <code>lower</code> or <code>upper</code> is <code>-Inf</code> or <code>Inf</code>, respectively, the set is interpreted as a one-sided interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L71-L76">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SecondOrderCone" href="#MathOptInterface.SecondOrderCone"><code>MathOptInterface.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SecondOrderCone(dim)</code></pre><p>The second-order cone (or Lorenz cone) <span>$\{ (t,x) \in \mathbb{R}^{dim} : t \ge || x ||_2 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L84-L88">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ExponentialCone" href="#MathOptInterface.ExponentialCone"><code>MathOptInterface.ExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialCone()</code></pre><p>The 3-dimensional exponential cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L93-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualExponentialCone" href="#MathOptInterface.DualExponentialCone"><code>MathOptInterface.DualExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualExponentialCone()</code></pre><p>The 3-dimensional dual exponential cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le \exp(1) w, u &lt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L101-L105">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PowerCone" href="#MathOptInterface.PowerCone"><code>MathOptInterface.PowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PowerCone(a)</code></pre><p>The 3-dimensional power cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^{a} y^{1-a} &gt;= |z|, x \ge 0, y \ge 0 \}$</span> with parameter <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L109-L113">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualPowerCone" href="#MathOptInterface.DualPowerCone"><code>MathOptInterface.DualPowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualPowerCone(a)</code></pre><p>The 3-dimensional power cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : (\frac{u}{a})^a (\frac{v}/{1-a})^{1-a} &gt;= |w|, u \ge 0, v \ge 0 \}$</span> with parameter <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L118-L122">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeTriangle" href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeTriangle(dim)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals unscaled. The entries of the upper triangular part of the matrix are given row by row (or equivalently, the entries of the lower triangular part are given column by column). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <code>dim</code>, the corresponding symmetric matrix has side dimension <span>$\sqrt (1/4 + 2 dim) - 1/2$</span> elements. The scalar product is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 3\\
  2 &amp; 4 &amp; 5\\
  3 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>corresponds to <span>$(1, 2, 3, 4, 5, 6)$</span> for <code>PositiveSemidefiniteConeTriangle</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L129-L148">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeScaled" href="#MathOptInterface.PositiveSemidefiniteConeScaled"><code>MathOptInterface.PositiveSemidefiniteConeScaled</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeScaled(dim)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals scaled. The entries of the upper triangular part of the matrix are given row by row (or equivalently, the entries of the lower triangular part are given column by column). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <code>dim</code>, the corresponding symmetric matrix has side dimension <span>$\sqrt (1/4 + 2 dim) - 1/2$</span> elements. The off-diagonal entries of the matrices of both the cone and its dual are scaled by <span>$\sqrt{2}$</span> and the scalar product is simply the sum of the pairwise product of the entries.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 3\\
  2 &amp; 4 &amp; 5\\
  3 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>and to <span>$(1, 2\sqrt{2}, 3\sqrt{2}, 4, 5\sqrt{2}, 6)$</span> for <code>PositiveSemidefiniteConeScaled</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L153-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Integers" href="#MathOptInterface.Integers"><code>MathOptInterface.Integers</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Integers()</code></pre><p>The set of integers <span>$\mathbb{Z}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L177-L181">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ZeroOne" href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ZeroOne()</code></pre><p>The set <span>$\{ 0, 1 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L184-L188">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS1" href="#MathOptInterface.SOS1"><code>MathOptInterface.SOS1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS1(weights)</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L193-L201">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS2" href="#MathOptInterface.SOS2"><code>MathOptInterface.SOS2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS2(weights)</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L206-L214">source</a><br/></section><p>Functions for getting and setting properties of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.dimension" href="#MathOptInterface.dimension"><code>MathOptInterface.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dimension(s::AbstractSet)</code></pre><p>Return the dimension (number of vector components) in the set <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/sets.jl#L10-L14">source</a><br/></section><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><p>Variable references and functions for adding and deleting variables.</p><p>[attribute that points to the (scalar) variable domain??? eg GreaterThan, NonNegatives, ZeroOne, SemiInteger]</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableReference" href="#MathOptInterface.VariableReference"><code>MathOptInterface.VariableReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableReference</code></pre><p>A lightweight object used to reference variables in a solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L61-L65">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.candelete-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.VariableReference}" href="#MathOptInterface.candelete-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.VariableReference}"><code>MathOptInterface.candelete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">candelete(m::AbstractSolverInstance, ref::VariableReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this variable can be removed from the solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L70-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.VariableReference}" href="#MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.VariableReference}"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractSolverInstance, ref::VariableReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference is valid for an active variable in the solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L77-L81">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.VariableReference}" href="#Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.VariableReference}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(m::AbstractSolverInstance, ref::VariableReference)</code></pre><p>Delete the referenced variable from the solver instance.</p><pre><code class="language-none">delete!(m::AbstractSolverInstance, refs::Vector{VariableReference})</code></pre><p>Delete the referenced variables in the vector <code>refs</code> from the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L84-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariables!" href="#MathOptInterface.addvariables!"><code>MathOptInterface.addvariables!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariables!(m::AbstractSolverInstance, n::Int)::Vector{VariableReference}</code></pre><p>Add <code>n</code> scalar variables to the solver instance, returning a vector of variable references.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/variables.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariable!" href="#MathOptInterface.addvariable!"><code>MathOptInterface.addvariable!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariable!(m::AbstractSolverInstance)::VariableReference</code></pre><p>Add a scalar variable to the solver instance, returning a variable reference. In addition, there is a special case for adding variables to existing linear problems.</p><pre><code class="language-none">addvariable!(m::AbstractSolverInstance, cref::Vector{Union{AffineConstraintRef{NonPositive}, AffineConstraintRef{NonNegative}, AffineConstraintRef{Zero}, AffineConstraintRef{Interval}}}, coefs)::VariableReference</code></pre><p>Add a variable with coefficients specified by <code>coefs</code> in the existing affine constraints given by the constraint references <code>cref</code>. To add a variable with coefficients in a constraint that is not listed here, use <code>addvariable!(m)</code> and then <code>modifyconstraint!</code> instead.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/variables.jl#L10-L20">source</a><br/></section><p>List of attributes associated with variables. [category AbstractVariableAttribute] Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>VariableReference</code> or a vector of <code>VariableReference</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimalStart" href="#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimalStart()</code></pre><p>An initial assignment of the variables that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L332-L336">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimal" href="#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimal(N)
VariablePrimal()</code></pre><p>The assignment to the primal variables in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L339-L345">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableBasisStatus" href="#MathOptInterface.VariableBasisStatus"><code>MathOptInterface.VariableBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given variable, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L351-L355">source</a><br/></section><h2><a class="nav-anchor" id="Objectives-1" href="#Objectives-1">Objectives</a></h2><p>Functions for adding and modifying objectives.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.setobjective!" href="#MathOptInterface.setobjective!"><code>MathOptInterface.setobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setobjective!(m::AbstractSolverInstance, b, a_varref::Vector{VariableReference}, a_coef, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, N::Int=1)</code></pre><p>Set the <code>N</code>th objective in the solver instance <code>m</code> to be <span>$\frac{1}{2} x^T Q_0 x + a_0^T x + b_0$</span>, where:</p><ul><li><p><span>$a_0$</span> is a sparse vector specified in tuple form by <code>a_varref, a_coef</code></p></li><li><p><span>$b_0$</span> is a scalar</p></li><li><p>the symmetric matrix <span>$Q_0$</span> is defined by the triplets in <code>Q_vari, Q_varj, Q_coef</code></p></li></ul><p>Duplicate indices (sparse) in either the <span>$a_0$</span> vector or the <span>$Q_0$</span> matrix are accepted and will be summed together. Off-diagonal entries of <span>$Q_0$</span> will be mirrored, so either the upper triangular or lower triangular entries of <span>$Q_0$</span> should be provided. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms. <code>a_varref</code>, <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><pre><code class="language-none">setobjective!(m::AbstractSolverInstance, b, a_varref::Vector{VariableReference}, a_coef, N::Int=1)</code></pre><p>Set the <code>N</code>th objective in the solver instance <code>m</code> to be <span>$a_0^T x + b_0$</span>, where:</p><ul><li><p><span>$a_0$</span> is a sparse vector specified in tuple form by <code>a_varref, a_coef</code></p></li><li><p><span>$b_0$</span> is a scalar</p></li></ul><p>Duplicate indices (sparse) in either the <span>$a_0$</span> vector or the <span>$Q_0$</span> matrix are accepted and will be summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/objectives.jl#L3-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyobjective!" href="#MathOptInterface.modifyobjective!"><code>MathOptInterface.modifyobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyobjective!(m::AbstractSolverInstance, N::Int, args...)</code></pre><p>Modify elements of the <code>N</code>th objective depending on the arguments <code>args</code>. The <code>N</code>th objective has the form <span>$\frac{1}{2} x^T Q_0 x + a_0^T x + b_0$</span>.</p><p>There are three cases, below.</p><p><strong>Modify Constant term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractSolverInstance, N::Int, b)</code></pre><p>Set the constant term <span>$b_0$</span> of the <code>N</code>th objective to <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, 1.0)</code></pre><p><strong>Modify Linear term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractSolverInstance, N::Int, a_varidx, a_coef)</code></pre><p>Set elements given by <code>a_varidx</code> in the linear term of the <code>N</code>th objective to <code>a_coef</code>. Either <code>a_varidx</code> and <code>a_coef</code> are both singletons, or they should be collections with equal length. The behavior of duplicate entries in <code>a_varidx</code> is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, v, 1.0)
modifyobjective!(m, 1, [v1, v2], [1.0, 2.0])</code></pre><p><strong>Modify Quadratic term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractSolverInstance, N::Int, Q_vari, Q_varj, Q_coef)</code></pre><p>Set the elements in the quadratic term of the <code>N</code>th objective specified by the triplets <code>Q_vari, Q_varj, Q_coef</code>. Off-diagonal entries will be mirrored. <code>Q_vari, Q_varj</code> should be collections of <code>VariableReference</code> objects. The behavior of duplicate entries is undefined. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, v1, v2, 1.0)
modifyobjective!(m, 1, [v1, v2], [v1, v1], [1.0, 2.0])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/objectives.jl#L47-L98">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getobjectiveconstant" href="#MathOptInterface.getobjectiveconstant"><code>MathOptInterface.getobjectiveconstant</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getobjectiveconstant(m, N::Int=1)</code></pre><p>Return the constant term in the <code>N</code>th objective.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/objectives.jl#L26-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getobjectiveaffine" href="#MathOptInterface.getobjectiveaffine"><code>MathOptInterface.getobjectiveaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getobjectiveaffine(m, N::Int=1)</code></pre><p>Return the affine part of the <code>N</code>th objective in tuple form <code>(varref, coef)</code> where <code>varref</code> is a <code>VariableReference</code> and <code>coef</code> is a coefficient. Output is a tuple of two vectors.</p><pre><code class="language-none">getobjectiveaffine(m, v::VariableReference, N::Int=1)</code></pre><p>Return the coefficient for the variable <code>v</code> in the affine part of the <code>N</code>th objective.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/objectives.jl#L33-L42">source</a><br/></section><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><p>Constraint references and functions for adding, modifying, and removing constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablewiseConstraintReference" href="#MathOptInterface.VariablewiseConstraintReference"><code>MathOptInterface.VariablewiseConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablewiseConstraintReference{T}</code></pre><p>A lightweight object used to reference variablewise constraints in a solver instance. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L3-L8">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AffineConstraintReference" href="#MathOptInterface.AffineConstraintReference"><code>MathOptInterface.AffineConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AffineConstraintReference{T}</code></pre><p>A lightweight object used to reference affine-in-set constraints in a solver instance. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L13-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.QuadraticConstraintReference" href="#MathOptInterface.QuadraticConstraintReference"><code>MathOptInterface.QuadraticConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QuadraticConstraintReference{T}</code></pre><p>A lightweight object used to reference quadratic-in-set constraints in a solver instance. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L23-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.candelete-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}" href="#MathOptInterface.candelete-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}"><code>MathOptInterface.candelete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">candelete(m::AbstractSolverInstance, ref::ConstraintReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this constraint can be removed from the solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L35-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}" href="#MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractSolverInstance, ref::ConstraintReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference is valid for an active constraint in the solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L42-L46">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}" href="#Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(m::AbstractSolverInstance, ref::ConstraintReference)</code></pre><p>Delete the referenced constraint from the solver instance.</p><pre><code class="language-none">delete!(m::AbstractSolverInstance, refs::Vector{ConstraintReference})</code></pre><p>Delete the referenced constraints in the vector <code>refs</code> from the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/references.jl#L49-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addconstraint!" href="#MathOptInterface.addconstraint!"><code>MathOptInterface.addconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, b, a_constridx, a_v::Vector{VariableReference}, a_coef, Q_constridx, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, S::AbstractSet)::QuadraticConstraintReference{typeof(S)}</code></pre><p>Add the vector quadratic-in-set constraint <span>$q_i(x) + A_i^T x + b_i \in \mathcal{S}_i$</span>, where:</p><ul><li><p><span>$A_i$</span> is a sparse matrix specified in triplet form by <code>a_constridx, a_v, a_coef</code></p></li><li><p><span>$b_i$</span> is a vector specified by <code>b</code></p></li><li><p><span>$q_i(x)$</span> is a vector with component <span>$(q_i(x))_k$</span> defined as <span>$\frac{1}{2} x^T Q_{i,k} x$</span>, where each symmetric matrix <span>$Q_{i,k}$</span> has <code>Q_constridx</code> equal to <code>k</code> and is specified in triplet form by <code>Q_vari, Q_varj, Q_coef</code></p></li><li><p><span>$\mathcal{S}_i$</span> is a pre-defined set specified as <code>S</code></p></li></ul><p>Duplicate indices in either the <span>$A_i$</span> matrix or any <span>$Q_{i,k}$</span> matrix are accepted and will be summed together. Off-diagonal entries of <span>$Q_{i,k}$</span> will be mirrored, so either the upper triangular or lower triangular entries of <span>$Q_{i,k}$</span> should be provided. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms. <code>a_v</code>, <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, b, a_v::Vector{VariableReference}, a_coef, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, S::AbstractSet)::QuadraticConstraintReference{typeof(S)}</code></pre><p>Add the scalar quadratic-in-set constraint <span>$q_i(x) + a_i^T x + b_i \in \mathcal{S}_i$</span>, where:</p><ul><li><p><span>$a_i$</span> is a sparse vector specified in tuple form by <code>a_v, a_coef</code></p></li><li><p><span>$b_i$</span> is a scalar specified by <code>b</code></p></li><li><p><span>$q_i(x)$</span> is defined as <span>$\frac{1}{2} x^T Q_{i} x$</span>, where the symmetric matrix <span>$Q_{i}$</span> is specified in triplet form by <code>Q_vari, Q_varj, Q_coef</code></p></li><li><p><span>$\mathcal{S}_i$</span> is a pre-defined <em>scalar</em> set specified as <code>S</code></p></li></ul><p>Duplicate indices in the <span>$a_i$</span> or the <span>$Q_{i,k}$</span> are accepted and will be summed together.</p><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, b, a_constridx, a_v::Vector{VariableReference}, a_coef, S::AbstractSet)::AffineConstraintReference{typeof(S)}</code></pre><p>Add the vector affine-in-set constraint <span>$A_i^T x + b_i \in \mathcal{S}_i$</span>, where:</p><ul><li><p><span>$A_i$</span> is a sparse matrix specified in triplet form by <code>a_constridx, a_v, a_coef</code></p></li><li><p><span>$b_i$</span> is a vector specified by <code>b</code></p></li><li><p><span>$\mathcal{S}_i$</span> is a pre-defined set specified as <code>S</code></p></li></ul><p>Duplicate indices in the <span>$A_i$</span> are accepted and will be summed together.</p><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, b, a_v::Vector{VariableReference}, a_coef, S::AbstractSet)::AffineConstraintReference{typeof(S)}</code></pre><p>Add the scalar affine-in-set constraint <span>$a_i^T x + b_i \in \mathcal{S}_i$</span>, where:</p><ul><li><p><span>$a_i$</span> is a sparse vector specified in tuple form by <code>a_v, a_coef</code></p></li><li><p><span>$b_i$</span> is a scalar specified by <code>b</code></p></li><li><p><span>$\mathcal{S}_i$</span> is a pre-defined <em>scalar</em> set specified as <code>S</code></p></li></ul><p>Duplicate indices in the <span>$a_i$</span> are accepted and will be summed together.</p><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, vs::Vector{VariableReference}, S::AbstractSet)::VariablewiseConstraintReference{typeof(S)}</code></pre><p>Add the vector variable-wise constraint <span>$(x_j)_{j \in v_i} \in \mathcal{S}_i$</span>, where:</p><ul><li><p><span>$v_i$</span> is a list of variable indices specified as a vector of variable references <code>vs</code></p></li><li><p><span>$\mathcal{S}_i$</span> is a pre-defined set specified as <code>S</code></p></li></ul><p>Behavior is not defined for duplicate indices in the <span>$v_i$</span>.</p><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, v::VariableReference, S::AbstractSet)::VariablewiseConstraintReference{typeof(S)}</code></pre><p>Add the scalar variable-wise constraint <span>$x_j \in \mathcal{S}_i$</span>, where:</p><ul><li><p><span>$x_j$</span> is variable specified as a variable reference <code>v</code></p></li><li><p><span>$\mathcal{S}_i$</span> is a pre-defined <em>scalar</em> set specified as <code>S</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/constraints.jl#L3-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyconstraint!" href="#MathOptInterface.modifyconstraint!"><code>MathOptInterface.modifyconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference, k::Int, args...)</code></pre><p>Modify elements of the <code>k</code>th row of the constraint <code>c</code> depending on the arguments <code>args</code>. The <code>k</code>th row will have the form <span>$q_{i,k}(x) + A_{i,k}^T x + b_{i,k}$</span>. There are four cases.</p><p><strong>Modify Constant term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference, k::Int, b)</code></pre><p>Set the constant term of the <code>k</code>th row in the constraint <code>c</code> to <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, 1, 1.0)</code></pre><p><strong>Modify Linear term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference, k::Int, a_v::Vector{VariableReference}, a_coef)</code></pre><p>Set elements given by <code>a_v</code> in the linear term of the <code>k</code>th row in the constraint <code>c</code> to <code>a_coef</code>. Either <code>a_v</code> and <code>a_coef</code> are both singletons, or they should be collections with equal length. The behavior of duplicate entries in <code>a_v</code> is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, v, 1.0)
modifyconstraint!(m, c, [v_1, v_2], [1.0, 2.0])</code></pre><p><strong>Modify Quadratic term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference, k::Int, Q_vari, Q_varj, Q_coef)</code></pre><p>Set the elements in the quadratic term of the <code>k</code>th row of the constraint <code>c</code> specified by the triplets <code>Q_vari, Q_varj, Q_coef</code>. Off-diagonal entries will be mirrored. <code>Q_vari, Q_varj</code> should be collections of <code>VariableReference</code> objects. The behavior of duplicate entries is undefined. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, v_1, v_2, 1.0)
modifyconstraint!(m, c, [v_1, v_2], [v_1, v_1], [1.0, 2.0])</code></pre><p><strong>Modify Set</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference{Set}, S::Set)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>S</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{Interval}</code></p><pre><code class="language-julia">modifyconstraint!(m, c, Interval(0, 5))
modifyconstraint!(m, c, NonPositives) # errors</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/constraints.jl#L104-L169">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getconstraintconstant" href="#MathOptInterface.getconstraintconstant"><code>MathOptInterface.getconstraintconstant</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintconstant(m::AbstractSolverInstance, c::ConstraintReference)</code></pre><p>Return the <span>$b$</span> vector of the constraint <code>c</code>.</p><pre><code class="language-none">getconstraintconstant(m::AbstractSolverInstance, c::ConstraintReference, k::Int)</code></pre><p>Return the constant term of the <code>k</code>th row of the constraint <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/constraints.jl#L63-L71">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getconstraintaffine" href="#MathOptInterface.getconstraintaffine"><code>MathOptInterface.getconstraintaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintaffine(m::AbstractSolverInstance, c::ConstraintReference)</code></pre><p>Return the <span>$A_i$</span> matrix of the constraint corresponding to <code>c</code> in triplet form <code>(i, v, coef)</code>, where <code>v</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient value. Output is a tuple of three vectors.</p><pre><code class="language-none">getconstraintaffine(m::AbstractSolverInstance, c::ConstraintReference, k::Int)</code></pre><p>Return the <code>k</code>th row of the <span>$A_k$</span> matrix of the constraint corresponding to <code>c</code> in tuple form <code>(v, coef)</code>, where <code>v</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient value. Output is a tuple of two vectors.</p><pre><code class="language-none">getconstraintaffine(m::AbstractSolverInstance, c::ConstraintReference, k::Int, v::VariableReference)</code></pre><p>Return the element of the <span>$A_k$</span> matrix of the constraint corresponding to <code>c</code> in row <code>k</code> and variable <code>v</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/constraints.jl#L74-L88">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getconstraintquadratic" href="#MathOptInterface.getconstraintquadratic"><code>MathOptInterface.getconstraintquadratic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintquadratic(m::AbstractSolverInstance, c::ConstraintReference, k::Int)</code></pre><p>Return the <span>$Q_{i,k}$</span> matrix of the <code>k</code>th row of the constraint corresponding to <code>c</code> in triplet form <code>(v_1, v_2, coef)</code>, where <code>v_1, v_2</code> are <code>VariableReference</code>s, and <code>coef</code> is a coefficient value. Output is a tuple of three vectors. The <span>$Q_{i,k}$</span> matrix must be symmetric, and only one element is returned.</p><pre><code class="language-none">getconstraintquadratic(m::AbstractSolverInstance, c::ConstraintReference, k::Int, v_1::VariableReference, v_2::VariableReference)</code></pre><p>Return the element corresponding to <code>(v_1, v_2)</code> of the <span>$Q_{i,k}$</span> matrix of the <code>k</code>th row of the constraint corresponding to <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/constraints.jl#L91-L101">source</a><br/></section><p>List of attributes associated with constraints. [category AbstractConstraintAttribute] Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>ConstraintReference</code> or a vector of <code>ConstraintReference{T}</code> objects.</p><p>[why is ConstraintBasisStatus under constraint attributes but below we have a basis status attribute separately??]</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimalStart" href="#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimalStart()</code></pre><p>An initial assignment of the constraint primal values that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L374-L378">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDualStart" href="#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDualStart()</code></pre><p>An initial assignment of the constriant duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L381-L385">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimal" href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>The assignment to the constraint primal values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L388-L394">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDual" href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDual(N)
ConstraintDual()</code></pre><p>The assignment to the constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L400-L406">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintBasisStatus" href="#MathOptInterface.ConstraintBasisStatus"><code>MathOptInterface.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given constraint, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/34d11ff7042f282b20b4a2ddb86b1d1767be0ade/src/attributes.jl#L412-L416">source</a><br/></section><footer><hr/><a class="previous" href="apimanual.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
