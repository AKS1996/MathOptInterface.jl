<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="apimanual.html">Manual</a></li><li class="current"><a class="toctext" href="apireference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#Parameters-and-Attributes-1">Parameters and Attributes</a></li><li><a class="toctext" href="#Instance-1">Instance</a></li><li><a class="toctext" href="#Solver-instance-1">Solver instance</a></li><li><a class="toctext" href="#Variables-and-Constraints-1">Variables and Constraints</a></li><li><a class="toctext" href="#Functions-and-function-modifications-1">Functions and function modifications</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Objective-modifications-1">Objective modifications</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/master/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><p>[Some introduction to API. List basic standalone methods.]</p><h2><a class="nav-anchor" id="Parameters-and-Attributes-1" href="#Parameters-and-Attributes-1">Parameters and Attributes</a></h2><p>Parameter abstract type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverParameter" href="#MathOptInterface.AbstractSolverParameter"><code>MathOptInterface.AbstractSolverParameter</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverParameter</code></pre><p>Abstract supertype for parameter objects that can be used to set or get parameters of the solver.</p><p><strong>Note</strong></p><p>The difference between <code>AbstractSolverParameter</code> and <code>AbstractInstanceAttribute</code> lies in the behavior of <code>isempty</code>, <code>empty!</code> and <code>copy!</code>. Typically solver parameters only affect how the instance is solved.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L3-L12">source</a></section><p>List of attribute categories.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractInstanceAttribute" href="#MathOptInterface.AbstractInstanceAttribute"><code>MathOptInterface.AbstractInstanceAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractInstanceAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractVariableAttribute" href="#MathOptInterface.AbstractVariableAttribute"><code>MathOptInterface.AbstractVariableAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractVariableAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractConstraintAttribute" href="#MathOptInterface.AbstractConstraintAttribute"><code>MathOptInterface.AbstractConstraintAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractConstraintAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L29-L33">source</a></section><p>Functions for getting and setting parameters and attributes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canget" href="#MathOptInterface.canget"><code>MathOptInterface.canget</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canget(instance::AbstractInstance, param::AbstractSolverParameter)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> currently has a value for the parameter specified by parameter type <code>param</code>.</p><pre><code class="language-none">canget(instance::AbstractInstance, attr::AbstractInstanceAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> currently has a value for the attribute specified by attribute type <code>attr</code>.</p><pre><code class="language-none">canget(instance::AbstractInstance, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> currently has a value for the attribute specified by attribute type <code>attr</code> applied to <em>every</em> variable of the instance.</p><pre><code class="language-none">canget(instance::AbstractInstance, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> currently has a value for the attribute specified by attribute type <code>attr</code> applied to <em>every</em> <code>F</code>-in-<code>S</code> constraint.</p><pre><code class="language-none">canget(instance::AbstractInstance, ::Type{VariableIndex}, name::String)::Bool</code></pre><p>Return a <code>Bool</code> indicating if a variable with the name <code>name</code> exists in <code>instance</code>.</p><pre><code class="language-none">canget(instance::AbstractInstance, ::Type{ConstraintIndex{F,S}}, name::String)::Bool where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>Return a <code>Bool</code> indicating if an <code>F</code>-in-<code>S</code> constraint with the name <code>name</code> exists in <code>instance</code>.</p><pre><code class="language-none">canget(instance::AbstractInstance, ::Type{ConstraintIndex}, name::String)::Bool</code></pre><p>Return a <code>Bool</code> indicating if a constraint of any kind with the name <code>name</code> exists in <code>instance</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">canget(instance, ObjectiveValue())
canget(instance, VariablePrimalStart(), VariableIndex)
canget(instance, VariablePrimal(), VariableIndex)
canget(instance, ConstraintPrimal(), ConstraintIndex{SingleVariable,EqualTo{Float64}})
canget(instance, VariableIndex, &quot;var1&quot;)
canget(instance, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, &quot;con1&quot;)
canget(instance, ConstraintIndex, &quot;con1&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L135-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.get" href="#MathOptInterface.get"><code>MathOptInterface.get</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get(instance::AbstractInstance, param::AbstractSolverParameter)</code></pre><p>Return a parameter <code>param</code> of the instance <code>instance</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, attr::AbstractInstanceAttribute)</code></pre><p>Return an attribute <code>attr</code> of the instance <code>instance</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, attr::AbstractVariableAttribute, v::VariableIndex)</code></pre><p>Return an attribute <code>attr</code> of the variable <code>v</code> in instance <code>instance</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, attr::AbstractVariableAttribute, v::Vector{VariableIndex})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the instance <code>instance</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, attr::AbstractConstraintAttribute, c::ConstraintIndex)</code></pre><p>Return an attribute <code>attr</code> of the constraint <code>c</code> in instance <code>instance</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the instance <code>instance</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, ::Type{VariableIndex}, name::String)</code></pre><p>If a variable with name <code>name</code> exists in the instance <code>instance</code>, return the corresponding index, otherwise throw a <code>KeyError</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, ::Type{ConstraintIndex{F,S}}, name::String) where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>If an <code>F</code>-in-<code>S</code> constraint with name <code>name</code> exists in the instance <code>instance</code>, return the corresponding index, otherwise throw a <code>KeyError</code>.</p><pre><code class="language-none">get(instance::AbstractInstance, ::Type{ConstraintIndex}, name::String)</code></pre><p>If <em>any</em> constraint with name <code>name</code> exists in the instance <code>instance</code>, return the corresponding index, otherwise throw a <code>KeyError</code>. This version is available for convenience but may incur a performance penalty because it is not type stable.</p><p><strong>Examples</strong></p><pre><code class="language-julia">get(instance, ObjectiveValue())
get(instance, VariablePrimal(), ref)
get(instance, VariablePrimal(5), [ref1, ref2])
get(instance, OtherAttribute(&quot;something specific to cplex&quot;))
get(instance, VariableIndex, &quot;var1&quot;)
get(instance, ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}, &quot;con1&quot;)
get(instance, ConstraintIndex, &quot;con1&quot;)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L63-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.get!" href="#MathOptInterface.get!"><code>MathOptInterface.get!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get!(output, instance::AbstractInstance, args...)</code></pre><p>An in-place version of <code>get</code>. The signature matches that of <code>get</code> except that the the result is placed in the vector <code>output</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L124-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canset" href="#MathOptInterface.canset"><code>MathOptInterface.canset</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canset(instance::AbstractInstance, param::AbstractSolverParameter)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set the parameter <code>param</code> to the instance <code>instance</code>.</p><pre><code class="language-none">canset(instance::AbstractInstance, attr::AbstractInstanceAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set the attribute <code>attr</code> to the instance <code>instance</code>.</p><pre><code class="language-none">canset(instance::AbstractInstance, attr::AbstractVariableAttribute, R::Type{VariableIndex})::Bool
canset(instance::AbstractInstance, attr::AbstractConstraintAttribute, R::Type{ConstraintIndex{F,S})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> applied to the index type <code>R</code> in the instance <code>instance</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">canset(instance, ObjectiveValue())
canset(instance, VariablePrimalStart(), VariableIndex)
canset(instance, ConstraintPrimal(), ConstraintIndex{VectorAffineFunction{Float64},Nonnegatives})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L184-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.set!" href="#MathOptInterface.set!"><code>MathOptInterface.set!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">set!(instance::AbstractInstance, param::AbstractSolverParameter, value)</code></pre><p>Assign <code>value</code> to the parameter <code>param</code> of the instance <code>instance</code>.</p><pre><code class="language-none">set!(instance::AbstractInstance, attr::AbstractInstanceAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the instance <code>instance</code>.</p><pre><code class="language-none">set!(instance::AbstractInstance, attr::AbstractVariableAttribute, v::VariableIndex, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in instance <code>instance</code>.</p><pre><code class="language-none">set!(instance::AbstractInstance, attr::AbstractVariableAttribute, v::Vector{VariableIndex}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in instance <code>instance</code>.</p><pre><code class="language-none">set!(instance::AbstractInstance, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in instance <code>instance</code>.</p><pre><code class="language-none">set!(instance::AbstractInstance, attr::AbstractConstraintAttribute, c::Vector{ConstraintIndex{F,S}}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in instance <code>instance</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L210-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.supports" href="#MathOptInterface.supports"><code>MathOptInterface.supports</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">supports(instance::AbstractInstance, param::AbstractSolverParameter)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> supports the solver parameter <code>param</code>.</p><pre><code class="language-none">supports(instance::AbstractInstance, attr::AbstractInstanceAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> supports the instance attribute <code>attr</code>.</p><pre><code class="language-none">supports(instance::AbstractInstance, attr::AbstractVariableAttribute, ::Type{VariableIndex})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> supports the variable attribute <code>attr</code>.</p><pre><code class="language-none">supports(instance::AbstractInstance, attr::AbstractConstraintAttribute, ::Type{ConstraintIndex{F,S}})::Bool where {F,S}</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> supports the constraint attribute <code>attr</code> applied to an <code>F</code>-in-<code>S</code> constraint.</p><p>In other words, it should return <code>true</code> if <code>copy!(instance, src)</code> does not return <code>CopyUnsupportedAttribute</code> when the attribute <code>attr</code> is set to <code>src</code>. If the attribute is only not supported in specific circumstances, it should still return <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L39-L58">source</a></section><h2><a class="nav-anchor" id="Instance-1" href="#Instance-1">Instance</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractInstance" href="#MathOptInterface.AbstractInstance"><code>MathOptInterface.AbstractInstance</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractInstance</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L4-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractStandaloneInstance" href="#MathOptInterface.AbstractStandaloneInstance"><code>MathOptInterface.AbstractStandaloneInstance</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractStandaloneInstance</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem unattached to any particular solver. Does not have methods for solving or querying results.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L11-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverInstance" href="#MathOptInterface.AbstractSolverInstance"><code>MathOptInterface.AbstractSolverInstance</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverInstance</code></pre><p>Abstract supertype for objects representing an instance of an optimization problem tied to a particular solver. This is typically a solver&#39;s in-memory representation. In addition to <code>AbstractInstance</code>, <code>AbstractSolverInstance</code> objects let you solve the instance and query the solution.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L20-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isempty" href="#MathOptInterface.isempty"><code>MathOptInterface.isempty</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isempty(instance::AbstractInstance)</code></pre><p>Returns <code>false</code> if the <code>instance</code> has any instance attribute set or has any variables or constraints. Note that an empty instance can have solver parameters set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L65-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.empty!" href="#MathOptInterface.empty!"><code>MathOptInterface.empty!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">empty!(instance::AbstractInstance)</code></pre><p>Empty the instance, that is, remove from the instance <code>instance</code> all variables, constraints and instance attributes but not solver parameters.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L73-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.write" href="#MathOptInterface.write"><code>MathOptInterface.write</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">write(instance::AbstractInstance, filename::String)</code></pre><p>Writes the current instance data to the given file. Supported file types depend on the solver or standalone instance type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L47-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.read!" href="#MathOptInterface.read!"><code>MathOptInterface.read!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">read!(instance::AbstractInstance, filename::String)</code></pre><p>Read the file <code>filename</code> into the instance <code>instance</code>. If <code>m</code> is non-empty, this may throw an error.</p><p>Supported file types depend on the instance type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L55-L62">source</a></section><p>Copying</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.copy!" href="#MathOptInterface.copy!"><code>MathOptInterface.copy!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">copy!(dest::AbstractInstance, src::AbstractInstance, warnattributes=true)::CopyResult</code></pre><p>Copy the model from the instance <code>src</code> into the instance <code>dest</code>. The target instance <code>dest</code> is emptied, and all previous indices to variables or constraints in <code>dest</code> are invalidated. Returns a <code>CopyResult</code> object. If the copy is successfully, the <code>CopyResult</code> contains a dictionary-like object that translates variable and constraint indices from the <code>src</code> instance to the corresponding indices in the <code>dest</code> instance.</p><p>If an attribute <code>attr</code> cannot be copied from <code>src</code> to <code>dest</code> then an error is thrown. If a solver parameter cannot be copied then:</p><ul><li><p>If <code>warnattributes</code> is <code>true</code>, a warning is displayed, otherwise,</p></li><li><p>The attribute is silently ignored.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Given empty `AbstractInstance`s `src` and `dest`.

x = addvariable!(src)

isvalid(src, x)   # true
isvalid(dest, x)  # false (`dest` has no variables)

copy_result = copy!(dest, src)
if copy_result.status == CopySuccess
    index_map = copy_result.indexmap
    isvalid(dest, x) # false (unless index_map[x] == x)
    isvalid(dest, index_map[x]) # true
else
    println(&quot;Copy failed with status &quot;, copy_result.status)
    println(&quot;Failure message: &quot;, copy_result.message)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L112-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.CopyResult" href="#MathOptInterface.CopyResult"><code>MathOptInterface.CopyResult</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">struct CopyResult{T}
    status::CopyStatusCode
    message::String # Human-friendly explanation why the copy failed
    indexmap::T     # Only valid if status is CopySuccess
end</code></pre><p>A struct returned by <code>copy!</code> to indicate success or failure. If success, also exposes a map between the variable and constraint indices of the two instances.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L97-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.CopyStatusCode" href="#MathOptInterface.CopyStatusCode"><code>MathOptInterface.CopyStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CopyStatusCode</code></pre><p>An Enum of possible statuses returned by a <code>copy!</code> operation through the <code>CopyResult</code> struct.</p><ul><li><p><code>CopySuccess</code>: The copy was successful.</p></li><li><p><code>CopyUnsupportedAttribute</code>: The copy failed because the destination does not support an attribute present in the source.</p></li><li><p><code>CopyUnsupportedConstraint</code>: The copy failed because the destination does not support a constraint present in the source.</p></li><li><p><code>CopyOtherError</code>: The copy failed for a different reason.</p></li></ul><p>In the failure cases:</p><ul><li><p>See the corresponding <code>message</code> field of the <code>CopyResult</code> for an explanation of the failure.</p></li><li><p>The state of the destination instance is undefined.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L80-L94">source</a></section><p>List of instance attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Name" href="#MathOptInterface.Name"><code>MathOptInterface.Name</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Name()</code></pre><p>A string identifying the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L261-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveSense()</code></pre><p>The sense of the objective function, an <code>OptimizationSense</code> with value <code>MinSense</code>, <code>MaxSense</code>, or <code>FeasiblitySense</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L268-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfVariables()</code></pre><p>The number of variables in the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L277-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfVariableIndices" href="#MathOptInterface.ListOfVariableIndices"><code>MathOptInterface.ListOfVariableIndices</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfVariableIndices()</code></pre><p>A <code>Vector{VariableIndex}</code> indexing all variables present in the instance (i.e., of length equal to the value of <code>NumberOfVariables()</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L284-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraints" href="#MathOptInterface.ListOfConstraints"><code>MathOptInterface.ListOfConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfConstraints()</code></pre><p>A list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <code>NumberOfConstraints{F,S}()</code> has value greater than zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L307-L313">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfConstraints{F,S}()</code></pre><p>The number of constraints of the type <code>F</code>-in-<code>S</code> present in the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L300-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraintIndices" href="#MathOptInterface.ListOfConstraintIndices"><code>MathOptInterface.ListOfConstraintIndices</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfConstraintIndices{F,S}()</code></pre><p>A <code>Vector{ConstraintIndex{F,S}}</code> indexing all constraints of type <code>F</code>-in<code>S</code> in the instance (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L292-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfInstanceAttributesSet" href="#MathOptInterface.ListOfInstanceAttributesSet"><code>MathOptInterface.ListOfInstanceAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfInstanceAttributesSet()</code></pre><p>A <code>Vector{AbstractInstanceAttribute}</code> of all instance attributes that were set to the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L254-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfVariableAttributesSet" href="#MathOptInterface.ListOfVariableAttributesSet"><code>MathOptInterface.ListOfVariableAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfVariableAttributesSet()</code></pre><p>A <code>Vector{AbstractVariableAttribute}</code> of all variable attributes that were set to the instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L398-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraintAttributesSet" href="#MathOptInterface.ListOfConstraintAttributesSet"><code>MathOptInterface.ListOfConstraintAttributesSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfConstraintAttributesSet{F, S}()</code></pre><p>A <code>Vector{AbstractConstraintAttribute}</code> of all constraint attributes that were set to <code>F</code>-in-<code>S</code> constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L454-L458">source</a></section><p>There are no attributes specific to a standalone instance.</p><h2><a class="nav-anchor" id="Solver-instance-1" href="#Solver-instance-1">Solver instance</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">optimize!(instance::AbstractSolverInstance)</code></pre><p>Start the solution procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L30-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.free!" href="#MathOptInterface.free!"><code>MathOptInterface.free!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">free!(instance::AbstractSolverInstance)</code></pre><p>Release any resources and memory used by the solver instance. Note that the Julia garbage collector takes care of this automatically, but automatic collection cannot always be forced. This method is useful for more precise control of resources, especially in the case of commercial solvers with licensing restrictions on the number of concurrent runs. Users must discard the solver instance object after this method is invoked.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/MathOptInterface.jl#L37-L44">source</a></section><p>List of solver instance attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RawSolver()</code></pre><p>An object that may be used to access a solver-specific API for this solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L382-L386">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultCount()</code></pre><p>The number of results available.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L389-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveFunction{F&lt;:AbstractScalarFunction}()</code></pre><p>An <code>F</code> instance which represents the objective function. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user. Throws an <code>InexactError</code> if the objective function cannot be converted to <code>F</code>, e.g. the objective function is quadratic and <code>F</code> is <code>ScalarAffineFunction{Float64}</code> or it has non-integer coefficient and <code>F</code> is <code>ScalarAffineFunction{Int}</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L316-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveValue(resultidx::Int=1)</code></pre><p>The objective value of the <code>resultindex</code>th primal result.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L329-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveBound()</code></pre><p>The best known bound on the optimal objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L339-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RelativeGap()</code></pre><p>The final relative optimality gap, defined as <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L346-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolveTime()</code></pre><p>The total elapsed solution time (in seconds) as reported by the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L353-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SimplexIterations()</code></pre><p>The cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L360-L365">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BarrierIterations()</code></pre><p>The cumulative number of barrier iterations while solving a problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L368-L372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NodeCount()</code></pre><p>The total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L375-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatus()</code></pre><p>A <code>TerminationStatusCode</code> explaining why the solver stopped.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L529-L533">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PrimalStatus(N)
PrimalStatus()</code></pre><p>The <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L588-L594">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualStatus(N)
DualStatus()</code></pre><p>The <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L600-L606">source</a></section><h3><a class="nav-anchor" id="Termination-Status-1" href="#Termination-Status-1">Termination Status</a></h3><p>The <code>TerminationStatus</code> attribute indicates why the solver stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the solver stopped executing.</p><p><strong>OK</strong></p><p>These are generally OK statuses.</p><ul><li><p><code>Success</code>: the algorithm ran successfully and has a result; this includes cases where the algorithm converges to an infeasible point (NLP) or converges to a solution of a homogeneous self-dual problem and has a certificate of primal/dual infeasibility</p></li><li><p><code>InfeasibleNoResult</code>: the algorithm stopped because it decided that the problem is infeasible but does not have a result to return</p></li><li><p><code>UnboundedNoResult</code>: the algorithm stopped because it decided that the problem is unbounded but does not have a result to return</p></li><li><p><code>InfeasibleOrUnbounded</code>: the algorithm stopped because it decided that the problem is infeasible or unbounded (no result is available); this occasionally happens during MIP presolve</p></li></ul><p><strong>Limits</strong></p><p>The solver stopped because of some user-defined limit. To be documented: <code>IterationLimit</code>, <code>TimeLimit</code>, <code>NodeLimit</code>, <code>SolutionLimit</code>, <code>MemoryLimit</code>, <code>ObjectiveLimit</code>, <code>NormLimit</code>, <code>OtherLimit</code>.</p><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><p><code>SlowProgress</code>: the algorithm stopped because it was unable to continue making progress towards the solution</p></li><li><p><code>AlmostSuccess</code> should be used if there is additional information that relaxed convergence tolerances are satisfied</p></li></ul><p>To be documented: <code>NumericalError</code>, <code>InvalidInstance</code>, <code>InvalidOption</code>, <code>Interrupted</code>, <code>OtherError</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L536-L565">source</a></section><h3><a class="nav-anchor" id="Result-Status-1" href="#Result-Status-1">Result Status</a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes indicate how to interpret the result returned by the solver. The value of the attribute is of type <code>ResultStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><p><code>FeasiblePoint</code></p></li><li><p><code>NearlyFeasiblePoint</code></p></li><li><p><code>InfeasiblePoint</code></p></li><li><p><code>InfeasibilityCertificate</code></p></li><li><p><code>NearlyInfeasibilityCertificate</code></p></li><li><p><code>ReductionCertificate</code></p></li><li><p><code>NearlyReductionCertificate</code></p></li><li><p><code>UnknownResultStatus</code></p></li><li><p><code>OtherResultStatus</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L570-L585">source</a></section><h2><a class="nav-anchor" id="Variables-and-Constraints-1" href="#Variables-and-Constraints-1">Variables and Constraints</a></h2><h3><a class="nav-anchor" id="Basis-Status-1" href="#Basis-Status-1">Basis Status</a></h3><p>The <code>BasisStatus</code> attribute of a variable or constraint describes its status with respect to a basis, if one is known. The value of the attribute is of type <code>BasisStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BasisStatusCode" href="#MathOptInterface.BasisStatusCode"><code>MathOptInterface.BasisStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>VariableBasisStatus</code> and <code>ConstraintBasisStatus</code> attribute. This explains the status of a given element with respect to an optimal solution basis. Possible values are:</p><ul><li><p><code>Basic</code>: element is in the basis</p></li><li><p><code>Nonbasic</code>: element is not in the basis</p></li><li><p><code>NonbasicAtLower</code>: element is not in the basis and is at its lower bound</p></li><li><p><code>NonbasicAtUpper</code>: element is not in the basis and is at its upper bound</p></li><li><p><code>SuperBasic</code>: element is not in the basis but is also not at one of its bounds</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L438-L449">source</a></section><h3><a class="nav-anchor" id="Index-types-1" href="#Index-types-1">Index types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableIndex" href="#MathOptInterface.VariableIndex"><code>MathOptInterface.VariableIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableIndex</code></pre><p>A type-safe wrapper for <code>Int64</code> for use in referencing variables in an instance. To allow for deletion, indices need not be consecutive.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/indextypes.jl#L14-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintIndex" href="#MathOptInterface.ConstraintIndex"><code>MathOptInterface.ConstraintIndex</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintIndex{F,S}</code></pre><p>A type-safe wrapper for <code>Int64</code> for use in referencing <code>F</code>-in-<code>S</code> constraints in an instance. The parameter <code>F</code> is the type of the function in the constraint, and the parameter <code>S</code> is the type of set in the constraint. To allow for deletion, indices need not be consecutive.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/indextypes.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.candelete" href="#MathOptInterface.candelete"><code>MathOptInterface.candelete</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">candelete(instance::AbstractInstance, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the object referred to by <code>index</code> can be removed from the instance <code>instance</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/indextypes.jl#L26-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid" href="#MathOptInterface.isvalid"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isvalid(instance::AbstractInstance, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this index refers to a valid object in the instance <code>instance</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/indextypes.jl#L33-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.ConstraintIndex, MathOptInterface.VariableIndex}}" href="#Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.ConstraintIndex, MathOptInterface.VariableIndex}}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(instance::AbstractInstance, index::Index)</code></pre><p>Delete the referenced object from the instance.</p><pre><code class="language-none">delete!{R}(instance::AbstractInstance, indices::Vector{R&lt;:Index})</code></pre><p>Delete the referenced objects in the vector <code>indices</code> from the instance. It may be assumed that <code>R</code> is a concrete type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/indextypes.jl#L40-L49">source</a></section><h3><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h3><p>Functions for adding variables. For deleting, see index types section.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canaddvariable" href="#MathOptInterface.canaddvariable"><code>MathOptInterface.canaddvariable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canaddvariable(instance::AbstractInstance)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to add a variable to the instance <code>instance</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/variables.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariables!" href="#MathOptInterface.addvariables!"><code>MathOptInterface.addvariables!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariables!(instance::AbstractInstance, n::Int)::Vector{VariableIndex}</code></pre><p>Add <code>n</code> scalar variables to the instance, returning a vector of variable indices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/variables.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariable!" href="#MathOptInterface.addvariable!"><code>MathOptInterface.addvariable!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariable!(instance::AbstractInstance)::VariableIndex</code></pre><p>Add a scalar variable to the instance, returning a variable index.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/variables.jl#L17-L21">source</a></section><p>List of attributes associated with variables. [category AbstractVariableAttribute] Calls to <code>get</code> and <code>set!</code> should include as an argument a single <code>VariableIndex</code> or a vector of <code>VariableIndex</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableName" href="#MathOptInterface.VariableName"><code>MathOptInterface.VariableName</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableName()</code></pre><p>A string identifying the variable. It is invalid for two variables to have the same name.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L405-L409">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimalStart" href="#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimalStart()</code></pre><p>An initial assignment of the variables that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L412-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimal" href="#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimal(N)
VariablePrimal()</code></pre><p>The assignment to the primal variables in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L419-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableBasisStatus" href="#MathOptInterface.VariableBasisStatus"><code>MathOptInterface.VariableBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given variable, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L431-L435">source</a></section><h3><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h3><p>Functions for adding and modifying constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.ConstraintIndex}" href="#MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.ConstraintIndex}"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(instance::AbstractInstance, index::Index)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this index refers to a valid object in the instance <code>instance</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/indextypes.jl#L33-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canaddconstraint" href="#MathOptInterface.canaddconstraint"><code>MathOptInterface.canaddconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canaddconstraint(instance::AbstractInstance, ::Type{F}, ::Type{S})::Bool where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to add a constraint <span>$f(x) \in \mathcal{S}$</span> where <span>$f$</span> is of type <code>F</code>, and <span>$\mathcal{S}$</span> is of type <code>S</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addconstraint!" href="#MathOptInterface.addconstraint!"><code>MathOptInterface.addconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraint!(instance::AbstractInstance, func::F, set::S)::ConstraintIndex{F,S} where {F,S}</code></pre><p>Add the constraint <span>$f(x) \in \mathcal{S}$</span> where <span>$f$</span> is defined by <code>func</code>, and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p><pre><code class="language-none">addconstraint!(instance::AbstractInstance, v::VariableIndex, set::S)::ConstraintIndex{SingleVariable,S} where {S}
addconstraint!(instance::AbstractInstance, vec::Vector{VariableIndex}, set::S)::ConstraintIndex{VectorOfVariables,S} where {S}</code></pre><p>Add the constraint <span>$v \in \mathcal{S}$</span> where <span>$v$</span> is the variable (or vector of variables) referenced by <code>v</code> and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L19-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addconstraints!" href="#MathOptInterface.addconstraints!"><code>MathOptInterface.addconstraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraints!(instance::AbstractInstance, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintIndex{F,S}} where {F,S}</code></pre><p>Add the set of constraints specified by each function-set pair in <code>funcs</code> and <code>sets</code>. <code>F</code> and <code>S</code> should be concrete types. This call is equivalent to <code>addconstraint!.(instance, funcs, sets)</code> but may be more efficient.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L35-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyconstraint!" href="#MathOptInterface.modifyconstraint!"><code>MathOptInterface.modifyconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Modify Function</strong></p><pre><code class="language-none">modifyconstraint!(instance::AbstractInstance, c::ConstraintIndex{F,S}, func::F)</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableIndex</code> objects,</p><pre><code class="language-julia">modifyconstraint!(instance, c, ScalarAffineFunction([v1,v2],[1.0,2.0],5.0))
modifyconstraint!(instance, c, SingleVariable(v1)) # Error</code></pre><p><strong>Modify Set</strong></p><pre><code class="language-none">modifyconstraint!(instance::AbstractInstance, c::ConstraintIndex{F,S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{F,Interval}</code></p><pre><code class="language-julia">modifyconstraint!(instance, c, Interval(0, 5))
modifyconstraint!(instance, c, NonPositives) # Error</code></pre><p><strong>Partial Modifications</strong></p><pre><code class="language-none">modifyconstraint!(instance::AbstractInstance, c::ConstraintIndex, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the function of constraint <code>c</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(instance, c, ScalarConstantChange(10.0))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L74-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canmodifyconstraint" href="#MathOptInterface.canmodifyconstraint"><code>MathOptInterface.canmodifyconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Modify Function</strong></p><pre><code class="language-none">canmodifyconstraint(instance::AbstractInstance, c::ConstraintIndex{F,S}, ::Type{F})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the function in constraint <code>c</code> can be replaced by another function of the same type <code>F</code> as the original function.</p><p><strong>Modify Set</strong></p><pre><code class="language-none">canmodifyconstraint(instance::AbstractInstance, c::ConstraintIndex{F,S}, ::Type{S})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the set in constraint <code>c</code> can be replaced by another set of the same type <code>S</code> as the original set.</p><p><strong>Partial Modifications</strong></p><pre><code class="language-none">canmodifyconstraint(instance::AbstractInstance, c::ConstraintIndex, ::Type{M})::Bool where M&lt;:AbstractFunctionModification</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to apply a modification of type <code>M</code> to the function of constraint <code>c</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">canmodifyconstraint(instance, c, ScalarConstantChange{Float64})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L46-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.transformconstraint!" href="#MathOptInterface.transformconstraint!"><code>MathOptInterface.transformconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Transform Constraint Set</strong></p><pre><code class="language-none">transformconstraint!(instance::AbstractInstance, c::ConstraintIndex{F,S1}, newset::S2)::ConstraintIndex{F,S2}</code></pre><p>Replace the set in constraint <code>c</code> with <code>newset</code>. The constraint index <code>c</code> will no longer be valid, and the function returns a new constraint index with the correct type.</p><p>Solvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a <code>LessThan</code> to <code>GreaterThan</code> set). In addition, set modification (where <code>S1 = S2</code>) should be performed via the <code>modifyconstraint!</code> function.</p><p>Typically, the user should delete the constraint and add a new one.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}</code>,</p><pre><code class="language-julia">c2 = transformconstraint!(instance, c, GreaterThan(0.0))
transformconstraint!(instance, c, LessThan(0.0)) # errors</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L120-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cantransformconstraint" href="#MathOptInterface.cantransformconstraint"><code>MathOptInterface.cantransformconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Transform Constraint Set</strong></p><pre><code class="language-none">cantransformconstraint(instance::AbstractInstance, c::ConstraintIndex{F,S1}, ::Type{S2})::Bool where S2&lt;:AbstractSet</code></pre><p>Return a <code>Bool</code> indicating whether the set of type <code>S1</code> in constraint <code>c</code> can be replaced by a set of type <code>S2</code>.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintIndex{ScalarAffineFunction{Float64},LessThan{Float64}}</code>,</p><pre><code class="language-julia">cantransformconstraint(instance, c, GreaterThan(0.0)) # true
cantransformconstraint(instance, c, ZeroOne())        # false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L155-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.supportsconstraint" href="#MathOptInterface.supportsconstraint"><code>MathOptInterface.supportsconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">supportsconstraint(instance::AbstractInstance, ::Type{F}, ::Type{S})::Bool where {F&lt;:AbstractFunction,S&lt;:AbstractSet}</code></pre><p>Return a <code>Bool</code> indicating whether <code>instance</code> supports <code>F</code>-in-<code>S</code> constraints, that is, <code>copy!(instance, src)</code> does not return <code>CopyUnsupportedConstraint</code> when <code>src</code> contains <code>F</code>-in-<code>S</code> constraints. If <code>F</code>-in-<code>S</code> constraints are only not supported in specific circumstances, e.g. <code>F</code>-in-<code>S</code> constraints cannot be combined with another type of constraint, it should still return <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/constraints.jl#L3-L9">source</a></section><p>List of attributes associated with constraints. [category AbstractConstraintAttribute] Calls to <code>get</code> and <code>set!</code> should include as an argument a single <code>ConstraintIndex</code> or a vector of <code>ConstraintIndex{F,S}</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintName" href="#MathOptInterface.ConstraintName"><code>MathOptInterface.ConstraintName</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintName()</code></pre><p>A string identifying the constraint. It is invalid for two constraints of any kind to have the same name.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L461-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimalStart" href="#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimalStart()</code></pre><p>An initial assignment of the constraint primal values that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L468-L472">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDualStart" href="#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDualStart()</code></pre><p>An initial assignment of the constraint duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L475-L479">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimal" href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>The assignment to the constraint primal values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L482-L488">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDual" href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDual(N)
ConstraintDual()</code></pre><p>The assignment to the constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L494-L500">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintBasisStatus" href="#MathOptInterface.ConstraintBasisStatus"><code>MathOptInterface.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given constraint, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L506-L510">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintFunction" href="#MathOptInterface.ConstraintFunction"><code>MathOptInterface.ConstraintFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintFunction()</code></pre><p>Return the <code>AbstractFunction</code> object used to define the constraint. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L513-L518">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintSet" href="#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintSet()</code></pre><p>Return the <code>AbstractSet</code> object used to define the constraint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/attributes.jl#L521-L525">source</a></section><h2><a class="nav-anchor" id="Functions-and-function-modifications-1" href="#Functions-and-function-modifications-1">Functions and function modifications</a></h2><p>List of recognized functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractFunction" href="#MathOptInterface.AbstractFunction"><code>MathOptInterface.AbstractFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractFunction</code></pre><p>Abstract supertype for function objects.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SingleVariable" href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SingleVariable(variable)</code></pre><p>The function that extracts the scalar variable referenced by <code>variable</code>, a <code>VariableIndex</code>. This function is naturally be used for single variable bounds or integrality constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L25-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorOfVariables" href="#MathOptInterface.VectorOfVariables"><code>MathOptInterface.VectorOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorOfVariables(variables)</code></pre><p>The function that extracts the vector of variables referenced by <code>variables</code>, a <code>Vector{VariableIndex}</code>. This function is naturally be used for constraints that apply to groups of variables, such as an &quot;all different&quot; constraint, an indicator constraint, or a complementarity constraint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L35-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarAffineFunction" href="#MathOptInterface.ScalarAffineFunction"><code>MathOptInterface.ScalarAffineFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarAffineFunction{T}(variables, coefficients, constant)</code></pre><p>The scalar-valued affine function <span>$a^T x + b$</span>, where:</p><ul><li><p><span>$a$</span> is a sparse vector specified in tuple form by <code>variables::Vector{VariableIndex}</code> and <code>coefficients::Vector{T}</code></p></li><li><p><span>$b$</span> is a scalar specified by <code>constant::T</code></p></li></ul><p>Duplicate variable indices in <code>variables</code> are accepted, and the corresponding coefficients are summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L45-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorAffineFunction" href="#MathOptInterface.VectorAffineFunction"><code>MathOptInterface.VectorAffineFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorAffineFunction{T}(outputindex, variables, coefficients, constant)</code></pre><p>The vector-valued affine function <span>$A x + b$</span>, where:</p><ul><li><p><span>$A$</span> is a sparse matrix specified in triplet form by <code>outputindex, variables, coefficients</code></p></li><li><p><span>$b$</span> is a vector specified by <code>constant</code></p></li></ul><p>Duplicate indices in the <span>$A$</span> are accepted, and the corresponding coefficients are summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L60-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarQuadraticFunction" href="#MathOptInterface.ScalarQuadraticFunction"><code>MathOptInterface.ScalarQuadraticFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarQuadraticFunction{T}(affine_variables, affine_coefficients, quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients, constant)</code></pre><p>The scalar-valued quadratic function <span>$\frac{1}{2}x^TQx + a^T x + b$</span>, where:</p><ul><li><p><span>$a$</span> is a sparse vector specified in tuple form by <code>affine_variables, affine_coefficients</code></p></li><li><p><span>$b$</span> is a scalar specified by <code>constant</code></p></li><li><p><span>$Q$</span> is a symmetric matrix is specified in triplet form by <code>quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients</code></p></li></ul><p>Duplicate indices in <span>$a$</span> or <span>$Q$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableIndex</code>es) are considered duplicates; only one need be specified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L76-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorQuadraticFunction" href="#MathOptInterface.VectorQuadraticFunction"><code>MathOptInterface.VectorQuadraticFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorQuadraticFunction{T}(affine_outputindex, affine_variables, affine_coefficients, quadratic_outputindex, quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients, constant)</code></pre><p>The vector-valued quadratic function with i<code>th</code> component (&quot;output index&quot;) defined as <span>$\frac{1}{2}x^TQ_ix + a_i^T x + b_i$</span>, where:</p><ul><li><p><span>$a_i$</span> is a sparse vector specified in tuple form by the subset of <code>affine_variables, affine_coefficients</code> for the indices <code>k</code> where <code>affine_outputindex[k] == i</code>.</p></li><li><p><span>$b_i$</span> is a scalar specified by <code>constant[i]</code></p></li><li><p><span>$Q_i$</span> is a symmetric matrix is specified in triplet form by the subset of <code>quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients</code> for the indices <code>k</code> where <code>quadratic_outputindex[k] == i</code></p></li></ul><p>Duplicate indices in <span>$a_i$</span> or <span>$Q_i$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableIndex</code>es) are considered duplicates; only one need be specified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L97-L107">source</a></section><p>List of function modifications.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarConstantChange" href="#MathOptInterface.ScalarConstantChange"><code>MathOptInterface.ScalarConstantChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarConstantChange{T}(new_constant)</code></pre><p>A struct used to request a change in the constant term of a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L129-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorConstantChange" href="#MathOptInterface.VectorConstantChange"><code>MathOptInterface.VectorConstantChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorConstantChange{T}(new_constant)</code></pre><p>A struct used to request a change in the constant vector of a vector-valued function. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L139-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarCoefficientChange" href="#MathOptInterface.ScalarCoefficientChange"><code>MathOptInterface.ScalarCoefficientChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarCoefficientChange{T}(variable, new_coefficient)</code></pre><p>A struct used to request a change in the linear coefficient of a single variable in a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L149-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.MultirowChange" href="#MathOptInterface.MultirowChange"><code>MathOptInterface.MultirowChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MultirowChange{T}(variable, rows, new_coefficients)</code></pre><p>A struct used to request a change in the linear coefficients of a single variable in a vector-valued function. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/functions.jl#L161-L167">source</a></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>List of recognized sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSet" href="#MathOptInterface.AbstractSet"><code>MathOptInterface.AbstractSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSet</code></pre><p>Abstract supertype for set objects used to encode constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Reals" href="#MathOptInterface.Reals"><code>MathOptInterface.Reals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Reals(dimension)</code></pre><p>The set <span>$\mathbb{R}^{dimension}$</span> (containing all points) of dimension <code>dimension</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L32-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Zeros" href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zeros(dimension)</code></pre><p>The set <span>$\{ 0 \}^{dimension}$</span> (containing only the origin) of dimension <code>dimension</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Nonnegatives" href="#MathOptInterface.Nonnegatives"><code>MathOptInterface.Nonnegatives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Nonnegatives(dimension)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dimension} : x \ge 0 \}$</span> of dimension <code>dimension</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L50-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Nonpositives" href="#MathOptInterface.Nonpositives"><code>MathOptInterface.Nonpositives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Nonpositives(dimension)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^{dimension} : x \le 0 \}$</span> of dimension <code>dimension</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L59-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GreaterThan" href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GreaterThan{T &lt;: Real}(lower::T)</code></pre><p>The set <span>$[lower,\infty) \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L68-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LessThan" href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LessThan{T &lt;: Real}(upper::T)</code></pre><p>The set <span>$(-\infty,upper] \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L77-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.EqualTo" href="#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EqualTo{T &lt;: Real}(value::T)</code></pre><p>The set containing the single point <span>$x \in \mathbb{R}$</span> where <span>$x$</span> is given by <code>value</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L86-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Interval" href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Interval{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The interval <span>$[lower, upper] \subseteq \mathbb{R}$</span>. If <code>lower</code> or <code>upper</code> is <code>-Inf</code> or <code>Inf</code>, respectively, the set is interpreted as a one-sided interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L95-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SecondOrderCone" href="#MathOptInterface.SecondOrderCone"><code>MathOptInterface.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SecondOrderCone(dimension)</code></pre><p>The second-order cone (or Lorenz cone) <span>$\{ (t,x) \in \mathbb{R}^{dimension} : t \ge || x ||_2 \}$</span> of dimension <code>dimension</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L106-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RotatedSecondOrderCone" href="#MathOptInterface.RotatedSecondOrderCone"><code>MathOptInterface.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RotatedSecondOrderCone(dimension)</code></pre><p>The rotated second-order cone <span>$\{ (t,u,x) \in \mathbb{R}^{dimension} : 2tu \ge || x ||_2^2, t,u \ge 0 \}$</span> of dimension <code>dimension</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L115-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GeometricMeanCone" href="#MathOptInterface.GeometricMeanCone"><code>MathOptInterface.GeometricMeanCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GeometricMeanCone(dimension)</code></pre><p>The geometric mean cone <span>$\{ (t,x) \in \mathbb{R}^{n+1} : x \ge 0, t \le \sqrt[n]{x_1 x_2 \cdots x_n} \}$</span> of dimension <code>dimension</code><span>${}=n+1$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L124-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ExponentialCone" href="#MathOptInterface.ExponentialCone"><code>MathOptInterface.ExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialCone()</code></pre><p>The 3-dimensional exponential cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L133-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualExponentialCone" href="#MathOptInterface.DualExponentialCone"><code>MathOptInterface.DualExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualExponentialCone()</code></pre><p>The 3-dimensional dual exponential cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le \exp(1) w, u &lt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L140-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PowerCone" href="#MathOptInterface.PowerCone"><code>MathOptInterface.PowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PowerCone{T &lt;: Real}(exponent::T)</code></pre><p>The 3-dimensional power cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^{exponent} y^{1-exponent} &gt;= |z|, x \ge 0, y \ge 0 \}$</span> with parameter <code>exponent</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L147-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualPowerCone" href="#MathOptInterface.DualPowerCone"><code>MathOptInterface.DualPowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualPowerCone{T &lt;: Real}(exponent::T)</code></pre><p>The 3-dimensional power cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : (\frac{u}{exponent})^{exponent} (\frac{v}{1-exponent})^{1-exponent} \ge |w|, u \ge 0, v \ge 0 \}$</span> with parameter <code>exponent</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L156-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeTriangle" href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeTriangle(dimension)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals unscaled. The entries of the upper triangular part of the matrix are given column by column (or equivalently, the entries of the lower triangular part are given row by row). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <span>$d$</span>, the corresponding symmetric matrix has side dimension <span>$\sqrt{1/4 + 2 d} - 1/2$</span> elements.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 4\\
  2 &amp; 3 &amp; 5\\
  4 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>corresponds to <span>$(1, 2, 3, 4, 5, 6)$</span> for <code>PositiveSemidefiniteConeTriangle</code></p><p><strong>Note</strong></p><p>Two packed storage formats exist for symmetric matrices, the respective orders of the entries are:</p><ul><li><p>upper triangular column by column (or lower triangular row by row);</p></li><li><p>lower triangular column by column (or upper triangular row by row).</p></li></ul><p>The advantage of the first format is the mapping between the <code>(i, j)</code> matrix indices and the <code>k</code> index of the vectorized form. It is simpler and does not depend on the dimension of the matrix. Indeed,</p><ul><li><p>the entry of matrix indices <code>(i, j)</code> has vectorized index <code>k = div((j-1)*j, 2) + i</code> if <span>$i \leq j$</span> and <code>k = div((i-1)*i, 2) + j</code> if <span>$j \leq i$</span>;</p></li><li><p>and the entry with vectorized index <code>k</code> has matrix indices <code>i = isqrt(2k)</code> and <code>j = k - div((i-1)*i, 2)</code> or <code>j = isqrt(2k)</code> and <code>i = k - div((j-1)*j, 2)</code>.</p></li></ul><p><strong>Duality note</strong></p><p>The scalar product for the symmetric matrix in its vectorized form is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries; see [p. 634, 1]. This has important consequence for duality. Consider for example the following problem</p><div>\[\begin{align*}
    &amp; \max_{x \in \mathbb{R}} &amp; x
    \\
    &amp; \;\;\text{s.t.} &amp;
    (1, -x, 1) &amp; \in \text{PositiveSemidefiniteConeTriangle}(2).
\end{align*}\]</div><p>The dual is the following problem</p><div>\[\begin{align*}
    &amp; \min_{x \in \mathbb{R}^3} &amp; y_1 + y_3
    \\
    &amp; \;\;\text{s.t.} &amp; 2y_2 &amp; = 1\\
    &amp; &amp; y &amp; \in \text{PositiveSemidefiniteConeTriangle}(2).
\end{align*}\]</div><p>Why do we use <span>$2y_2$</span> in the dual constraint instead of <span>$y_2$</span> ? The reason is that <span>$2y_2$</span> is the scalar product between <span>$y$</span> and the symmetric matrix whose vectorized form is <span>$(0, 1, 0)$</span>. Indeed, with our modified scalar products we have</p><div>\[\langle
(0, 1, 0),
(y_1, y_2, y_3)
\rangle
=
\mathrm{trace}
\begin{pmatrix}
  0 &amp; 1\\
  1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
  y_1 &amp; y_2\\
  y_2 &amp; y_3
\end{pmatrix}
= 2y_2.\]</div><p><strong>References</strong></p><p>[1] Boyd, S. and Vandenberghe, L.. <em>Convex optimization</em>. Cambridge university press, 2004.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L167-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeSquare" href="#MathOptInterface.PositiveSemidefiniteConeSquare"><code>MathOptInterface.PositiveSemidefiniteConeSquare</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeSquare(dimension)</code></pre><p>The cone of symmetric positive semidefinite matrices. The entries of the matrix are given column by column (or equivalently, row by row). The matrix is both constrained to be symmetric and and to be positive semidefinite. That is, if the functions in entries <span>$(i, j)$</span> and <span>$(j, i)$</span> are different, then a constraint will be added to make sure that the entries are equal.</p><p><strong>Examples</strong></p><p>Constraining the matrix</p><div>\[\begin{bmatrix}
  1 &amp; -y\\
  -z &amp; 0\\
\end{bmatrix}\]</div><p>to be symmetric positive semidefinite can be achieved by constraining the vector <span>$(1, -z, -y, 0)$</span> (or <span>$(1, -y, -z, 0)$</span>) to belong to the <code>PositiveSemidefiniteConeSquare(2)</code>. It both constrains <span>$y = z$</span> and <span>$(1, -y, 0)$</span> (or <span>$(1, -z, 0)$</span>) to be in <code>PositiveSemidefiniteConeTriangle</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L248-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LogDetConeTriangle" href="#MathOptInterface.LogDetConeTriangle"><code>MathOptInterface.LogDetConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LogDetConeTriangle(dimension)</code></pre><p>The Log-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d(d+1)/2} : t \le \log(\det(X)) \}$</span> where the matrix <code>X</code> is represented in the same symmetric packed format as in the <code>PositiveSemidefiniteConeTriangle</code>. The argument <code>dimension</code> is the dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L275-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LogDetConeSquare" href="#MathOptInterface.LogDetConeSquare"><code>MathOptInterface.LogDetConeSquare</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LogDetConeSquare(dimension)</code></pre><p>The Log-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d^2} : t \le \log(\det(X)), X \text{ symmetric} \}$</span> where the matrix <code>X</code> is represented in the same format as in the <code>PositiveSemidefiniteConeSquare</code>. Similarly to <code>PositiveSemidefiniteConeSquare</code>, constraints are added to ensures that <code>X</code> is symmetric. The argument <code>dimension</code> is the dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L285-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RootDetConeTriangle" href="#MathOptInterface.RootDetConeTriangle"><code>MathOptInterface.RootDetConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RootDetConeTriangle(dimension)</code></pre><p>The Root-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d(d+1)/2} : t \le \det(X)^{1/d} \}$</span> where the matrix <code>X</code> is represented in the same symmetric packed format as in the <code>PositiveSemidefiniteConeTriangle</code>. The argument <code>dimension</code> is the dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L296-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RootDetConeSquare" href="#MathOptInterface.RootDetConeSquare"><code>MathOptInterface.RootDetConeSquare</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RootDetConeSquare(dimension)</code></pre><p>The Root-Determinant cone <span>$\{ (t, X) \in \mathbb{R}^{1 + d^2} : t \le \det(X)^{1/d}, X \text{ symmetric} \}$</span> where the matrix <code>X</code> is represented in the same format as in the <code>PositiveSemidefiniteConeSquare</code>. Similarly to <code>PositiveSemidefiniteConeSquare</code>, constraints are added to ensures that <code>X</code> is symmetric. The argument <code>dimension</code> is the dimension of the matrix <code>X</code>, i.e., its number of rows or columns.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L306-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Integer" href="#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Integer()</code></pre><p>The set of integers <span>$\mathbb{Z}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L320-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ZeroOne" href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ZeroOne()</code></pre><p>The set <span>$\{ 0, 1 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L327-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Semicontinuous" href="#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Semicontinuous{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The set <span>$\{0\} \cup [lower,upper]$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L334-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Semiinteger" href="#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Semiinteger{T &lt;: Real}(lower::T,upper::T)</code></pre><p>The set <span>$\{0\} \cup \{lower,lower+1,\ldots,upper-1,upper\}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L344-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS1" href="#MathOptInterface.SOS1"><code>MathOptInterface.SOS1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS1{T &lt;: Real}(weights::Vector{T})</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L354-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS2" href="#MathOptInterface.SOS2"><code>MathOptInterface.SOS2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS2{T &lt;: Real}(weights::Vector{T})</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L367-L375">source</a></section><p>Functions for getting and setting properties of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.dimension" href="#MathOptInterface.dimension"><code>MathOptInterface.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dimension(s::AbstractVectorSet)</code></pre><p>Return the underlying dimension (number of vector components) in the set <code>s</code>, i.e., <span>$n$</span> if the set is a subset of <span>$\mathbb{R}^n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/sets.jl#L24-L29">source</a></section><h2><a class="nav-anchor" id="Objective-modifications-1" href="#Objective-modifications-1">Objective modifications</a></h2><p>Functions for modifying objective functions. Use <code>ObjectiveFunction</code> and <code>ObjectiveSense</code> to set and query the objective function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyobjective!" href="#MathOptInterface.modifyobjective!"><code>MathOptInterface.modifyobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyobjective!(instance::AbstractInstance, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the objective function of <code>instance</code>. To change the function completely, call <code>setobjective!</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(instance, ScalarConstantChange(10.0))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/objectives.jl#L3-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canmodifyobjective" href="#MathOptInterface.canmodifyobjective"><code>MathOptInterface.canmodifyobjective</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">canmodifyobjective(instance::AbstractInstance, ::Type{M})::Bool where M&lt;:AbstractFunctionModification</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to apply a modification of type <code>M</code> to the objective function of instance <code>instance</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">canmodifyobjective(instance, ScalarConstantChange{Float64})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/blob/20b2ecf5b5d6c2a66408affa0f1098b1836011f2/src/objectives.jl#L17-L27">source</a></section><footer><hr/><a class="previous" href="apimanual.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
