<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="apimanual.html">Manual</a></li><li class="current"><a class="toctext" href="apireference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Objectives-1">Objectives</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Attributes-1">Attributes</a></li><li><a class="toctext" href="#Status-Codes-1">Status Codes</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><p>Some introduction to API. List basic standalone methods.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractModel" href="#MathOptInterface.AbstractModel"><code>MathOptInterface.AbstractModel</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractModel</code></pre><p>Abstract supertype which represents a solver&#39;s in-memory representation of an optimization problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/MathOptInterface.jl#L12-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolver" href="#MathOptInterface.AbstractSolver"><code>MathOptInterface.AbstractSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolver</code></pre><p>Abstract supertype for &quot;solver&quot; objects. A solver is a lightweight object used for selecting solvers and parameters. It does not store any instance data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/MathOptInterface.jl#L5-L9">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Model" href="#MathOptInterface.Model"><code>MathOptInterface.Model</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Model(solver::AbstractMathProgSolver)</code></pre><p>Create an instance of <code>AbstractModel</code> using the given solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/MathOptInterface.jl#L20-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">optimize!(m::AbstractModel)</code></pre><p>Start the solution procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/MathOptInterface.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.freemodel!" href="#MathOptInterface.freemodel!"><code>MathOptInterface.freemodel!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">freemodel!(m::AbstractModel)</code></pre><p>Release any resources and memory used by the model. Note that the Julia garbage collector takes care of this automatically, but automatic collection cannot always be forced. This method is useful for more precise control of resources, especially in the case of commercial solvers with licensing restrictions on the number of concurrent runs. Users must discard the model object after this method is invoked.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/MathOptInterface.jl#L34-L43">source</a><br/></section><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableReference" href="#MathOptInterface.VariableReference"><code>MathOptInterface.VariableReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableReference</code></pre><p>A lightweight object used to reference variables in a model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L60-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.candelete-Tuple{MathOptInterface.AbstractModel,MathOptInterface.VariableReference}" href="#MathOptInterface.candelete-Tuple{MathOptInterface.AbstractModel,MathOptInterface.VariableReference}"><code>MathOptInterface.candelete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">candelete(m::AbstractModel, ref::VariableReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this variable can be removed from the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L69-L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractModel,MathOptInterface.VariableReference}" href="#MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractModel,MathOptInterface.VariableReference}"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractModel, ref::VariableReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference is valid for an active variable in the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L76-L81">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{MathOptInterface.AbstractModel,MathOptInterface.VariableReference}" href="#Base.delete!-Tuple{MathOptInterface.AbstractModel,MathOptInterface.VariableReference}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(m::AbstractModel, ref::VariableReference)</code></pre><p>Delete the referenced variable from the model.</p><pre><code class="language-none">delete!(m::AbstractModel, refs::Vector{VariableReference})</code></pre><p>Delete the referenced variables in the vector <code>refs</code> from the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L84-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariables!" href="#MathOptInterface.addvariables!"><code>MathOptInterface.addvariables!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariables!(m::AbstractModel, N::Int)::Vector{VariableReference}</code></pre><p>Add <code>N</code> scalar variables to the model, returning a vector of variable references.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/variables.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariable!" href="#MathOptInterface.addvariable!"><code>MathOptInterface.addvariable!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariable!(m::AbstractModel)::VariableReference</code></pre><p>Add a scalar variable to the model, returning a variable reference.</p><p>In addition, there is a special case for adding variables to existing linear problems.</p><pre><code class="language-none">addvariable!(m::AbstractModel,
    cref::Vector{Union{
            AffineConstraintRef{NonPositive},
            AffineConstraintRef{NonNegative},
            AffineConstraintRef{Zero},
            AffineConstraintRef{Interval}
        }},
    coefs)::VariableReference</code></pre><p>Add a variable with coefficients specified by <code>coefs</code> in the existing affine constraints given by the constraint references <code>cref</code>. If you want to add a variable with coefficients in a constraint that is not listed here (such as a quadratic term, or in the SOC), use <code>addvariable!(m)</code> and then <code>modifyconstraint!</code> instead.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/variables.jl#L9-L30">source</a><br/></section><h2><a class="nav-anchor" id="Objectives-1" href="#Objectives-1">Objectives</a></h2><p>How to add and set objectives.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.setobjective!" href="#MathOptInterface.setobjective!"><code>MathOptInterface.setobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setobjective!(m::AbstractModel, b, a_varref::Vector{VariableReference}, a_coef, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, N::Int=1)</code></pre><p>Set the <code>N</code>&#39;th objective in the model <code>m</code> to be</p><div>\[a^Tx + b + \frac{1}{2}x^TQx\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a scalar; and the symmetric matrix <span>$Q$</span> is defined by the triplets in <code>Q_vari</code>, <code>Q_varj</code>, <code>Q_coef</code>.</p><p>Duplicate indices in either the <span>$a$</span> vector or the <span>$Q$</span> matrix are accepted and will be summed together. Off-diagonal entries of <span>$Q$</span> will be mirrored, so either the upper triangular or lower triangular entries of <span>$Q$</span> should be provided. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms. <code>a_varref</code>, <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><pre><code class="language-none">setobjective!(m::AbstractModel, b, a_varref::Vector{VariableReference}, a_coef, N::Int=1)</code></pre><p>Set the <code>N</code>&#39;th objective in the model <code>m</code> to be</p><div>\[a^Tx + b\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code> and <code>a_coef</code> and <span>$b$</span> is a scalar.</p><p>Duplicate indices in either the <span>$a$</span> vector are accepted and will be summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/objectives.jl#L1-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyobjective!" href="#MathOptInterface.modifyobjective!"><code>MathOptInterface.modifyobjective!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyobjective!(m::AbstractModel, i::Int, args...)</code></pre><p>Modify elements of the <code>i</code>&#39;th objective depending on the arguments <code>args</code>. The <code>i</code>&#39;th objective will have the form:</p><div>\[    a_i^Tx + b_i + \frac{1}{2}x^TQ_ix\]</div><p>There are three cases.</p><p><strong>Modify Constant term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractModel, i::Int, b)</code></pre><p>Set the constant term of the <code>i</code>&#39;th row objective to <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, 1.0)</code></pre><p><strong>Modify Linear term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractModel, i::Int, a_varidx, a_coef)</code></pre><p>Set elements given by <code>a_varidx</code> in the linear term of the <code>i</code>&#39;th objective to <code>a_coef</code>. Either <code>a_varidx</code> and <code>a_coef</code> are both singletons, or they should be collections with equal length.</p><p>The behaviour of duplicate entries in <code>a_varidx</code> is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, v, 1.0)
modifyobjective!(m, 1, [v1, v2], [1.0, 2.0])</code></pre><p><strong>Modify Quadratic term</strong></p><pre><code class="language-none">modifyobjective!(m::AbstractModel, i::Int, Q_vari, Q_varj, Q_coef)</code></pre><p>Set the elements in the quadratic term of the <code>i</code>&#39;th objective specified by the triplets <code>Q_vari</code>, <code>Q_varj</code>, and <code>Q_coef</code>. Off-diagonal entries will be mirrored. <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><p>The behaviour of duplicate entries is undefined. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyobjective!(m, 1, v1, v2, 1.0)
modifyobjective!(m, 1, [v1, v2], [v1, v1], [1.0, 2.0])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/objectives.jl#L33-L89">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getobjectiveconstant" href="#MathOptInterface.getobjectiveconstant"><code>MathOptInterface.getobjectiveconstant</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getobjectiveconstant(m, i::Int=1)</code></pre><p>Return the constant term in the <code>i</code>&#39;th objective.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/objectives.jl#L92-L96">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getobjectiveaffine" href="#MathOptInterface.getobjectiveaffine"><code>MathOptInterface.getobjectiveaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getobjectiveaffine(m, i::Int=1)</code></pre><p>Return the affine part of the <code>i</code>&#39;th objective in tuple form <code>(varref,coef)</code> where <code>varref</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of two vectors.</p><pre><code class="language-none">getobjectiveaffine(m, v::VariableReference, i::Int=1)</code></pre><p>Return the coefficient for the variable <code>v</code> in the affine part of the <code>i</code>&#39;th objective.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/objectives.jl#L99-L107">source</a><br/></section><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><p>How to add and modify constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablewiseConstraintReference" href="#MathOptInterface.VariablewiseConstraintReference"><code>MathOptInterface.VariablewiseConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablewiseConstraintReference{T}</code></pre><p>A lightweight object used to reference variablewise constraints in a model. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AffineConstraintReference" href="#MathOptInterface.AffineConstraintReference"><code>MathOptInterface.AffineConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AffineConstraintReference{T}</code></pre><p>A lightweight object used to reference affine-in-set constraints in a model. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L11-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.QuadraticConstraintReference" href="#MathOptInterface.QuadraticConstraintReference"><code>MathOptInterface.QuadraticConstraintReference</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QuadraticConstraintReference{T}</code></pre><p>A lightweight object used to reference quadratic-in-set constraints in a model. The parameter <code>T</code> is the type of set constraint referenced.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L21-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.candelete-Tuple{MathOptInterface.AbstractModel,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}" href="#MathOptInterface.candelete-Tuple{MathOptInterface.AbstractModel,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}"><code>MathOptInterface.candelete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">candelete(m::AbstractModel, ref::ConstraintReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this constraint can be removed from the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L33-L37">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractModel,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}" href="#MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractModel,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractModel, ref::ConstraintReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference is valid for an active constraint in the model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L40-L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!-Tuple{MathOptInterface.AbstractModel,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}" href="#Base.delete!-Tuple{MathOptInterface.AbstractModel,Union{MathOptInterface.AffineConstraintReference, MathOptInterface.QuadraticConstraintReference, MathOptInterface.VariablewiseConstraintReference}}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">delete!(m::AbstractModel, ref::ConstraintReference)</code></pre><p>Delete the referenced constraint from the model.</p><pre><code class="language-none">delete!(m::AbstractModel, refs::Vector{ConstraintReference})</code></pre><p>Delete the referenced constraints in the vector <code>refs</code> from the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/references.jl#L48-L56">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addconstraint!" href="#MathOptInterface.addconstraint!"><code>MathOptInterface.addconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraint!(m::AbstractModel, b, a_constridx, a_varref::Vector{VariableReference}, a_coef, Q_constridx, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, S::AbstractSet)::QuadraticConstraintReference{typeof(S)}</code></pre><p>Add the quadratic-in-set constraint</p><div>\[Ax + b + q(x) \in S\]</div><p>where <span>$A$</span> is a sparse matrix specified in triplet form by <code>a_constridx</code>, <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a vector; <span>$q(x)$</span> is a vector with component <span>$(q(x))_k$</span> defined to be <span>$\frac{1}{2}x^TQ_kx$</span> where the symmetric matrix <span>$Q_k$</span> is defined by the triplets in <code>Q_vari</code>, <code>Q_varj</code>, <code>Q_coef</code> for which <code>Q_constridx</code> equals <code>k</code>; and the set <span>$S$</span> is defined by <code>S</code>.</p><p>Duplicate indices in either the <span>$A$</span> or the <span>$Q$</span> matrix are accepted and will be summed together. Off-diagonal entries of <span>$Q$</span> will be mirrored, so either the upper triangular or lower triangular entries of <span>$Q$</span> should be provided. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms. <code>a_varref</code>, <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><pre><code class="language-none">addconstraint!(m::AbstractModel, b, a_varref::Vector{VariableReference}, a_coef, Q_vari::Vector{VariableReference}, Q_varj::Vector{VariableReference}, Q_coef, S::AbstractSet)::QuadraticConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for one-dimensional sets. Add the constraint</p><div>\[a^Tx + b + \frac{1}{2}x^TQx \in S\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a scalar; the symmetric matrix <span>$Q$</span> is defined by the triplets in <code>Q_vari</code>, <code>Q_varj</code>, <code>Q_coef</code>; and the set <span>$S$</span> is defined by <code>S</code>.</p><pre><code class="language-none">addconstraint!(m::AbstractModel, b, a_constridx, a_varref::Vector{VariableReference}, a_coef, S::AbstractSet)::AffineConstraintReference{typeof(S)}</code></pre><p>Add the affine-in-set constraint</p><div>\[Ax + b \in S\]</div><p>where <span>$A$</span> is a sparse matrix specified in triplet form by <code>a_constridx</code>, <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a vector; and the set <span>$S$</span> is defined by <code>S</code>.</p><p>Duplicate indices either <span>$A$</span> are accepted and will be summed together.</p><pre><code class="language-none">addconstraint!(m::AbstractModel, b, a_varref::Vector{VariableReference}, a_coef, S::AbstractSet)::AffineConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for one-dimensional sets. Add the constraint</p><div>\[a^Tx + b \in S\]</div><p>where <span>$a$</span> is a sparse vector specified in tuple form by <code>a_varref</code>, and <code>a_coef</code>; <span>$b$</span> is a scalar; and the set <span>$S$</span> is defined by <code>S</code>.</p><pre><code class="language-none">addconstraint!(m::AbstractModel, varref::Vector{VariableReference}, S::AbstractSet)::VariablewiseConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for variablewise constraints. Add the constraint</p><div>\[x_{varref} \in S\]</div><p>where <code>varref</code> is a vector of variable references to specifiy the subset of the subvector of <code>x</code>.</p><pre><code class="language-none">addconstraint!(m::AbstractModel, varref::VariableReference, S::AbstractSet)::VariablewiseConstraintReference{typeof(S)}</code></pre><p>A specialized version of <code>addconstraint!</code> for one-dimensional variablewise constraints. Add the constraint</p><div>\[x_{varref} \in S\]</div><p>where <code>varref</code> is a single variable references to specifiy the index of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/constraints.jl#L1-L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyconstraint!" href="#MathOptInterface.modifyconstraint!"><code>MathOptInterface.modifyconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">modifyconstraint!(m::AbstractModel, c::ConstraintReference, i::Int, args...)</code></pre><p>Modify elements of the <code>i</code>&#39;th row of the constraint <code>c</code> depending on the arguments <code>args</code>. The <code>i</code>&#39;th row will have the form</p><div>\[    a_i^Tx + b_i + \frac{1}{2}x^TQ_ix \in S\]</div><p>There are three cases.</p><p><strong>Modify Constant term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractModel, c::ConstraintReference, i::Int, b)</code></pre><p>Set the constant term of the <code>i</code>&#39;th row in the constraint <code>c</code> to <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, 1, 1.0)</code></pre><p><strong>Modify Linear term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractModel, c::ConstraintReference, i::Int, a_varref::Vector{VariableReference}, a_coef)</code></pre><p>Set elements given by <code>a_varref</code> in the linear term of the <code>i</code>&#39;th element in the constraint <code>c</code> to <code>a_coef</code>. Either <code>a_varref</code> and <code>a_coef</code> are both singletons, or they should be collections with equal length.</p><p>The behaviour of duplicate entries in <code>a_varref</code> is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, v, 1.0)
modifyconstraint!(m, c, [v1, v2], [1.0, 2.0])</code></pre><p><strong>Modify Quadratic term</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractModel, c::ConstraintReference, i::Int, Q_vari, Q_varj, Q_coef)</code></pre><p>Set the elements in the quadratic term of the <code>i</code>&#39;th element of the constraint <code>c</code> specified by the triplets <code>Q_vari</code>, <code>Q_varj</code>, and <code>Q_coef</code>. Off-diagonal entries will be mirrored. <code>Q_vari</code>, <code>Q_varj</code> should be collections of <code>VariableReference</code> objects.</p><p>The behaviour of duplicate entries is undefined. If entries for both <span>$(i,j)$</span> and <span>$(j,i)$</span> are provided, these are considered duplicate terms.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, v1, v2, 1.0)
modifyconstraint!(m, c, [v1, v2], [v1, v1], [1.0, 2.0])</code></pre><p><strong>Modify Set</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractModel, c::ConstraintReference{S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{Interval}</code></p><pre><code class="language-julia">modifyconstraint!(m, c, Interval(0, 5))
modifyconstraint!(m, c, NonPositive) # errors</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/constraints.jl#L74-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getconstraintconstant" href="#MathOptInterface.getconstraintconstant"><code>MathOptInterface.getconstraintconstant</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintconstant(m::AbstractModel, c::ConstraintReference)</code></pre><p>Return the <span>$b$</span> vector of the constraint corresponding to <code>c</code>.</p><pre><code class="language-none">getconstraintconstant(m::AbstractModel, c::ConstraintReference, i::Int)</code></pre><p>Return the constant term of the <code>i</code>th row of the constraint corresponding to <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/constraints.jl#L150-L158">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getconstraintaffine" href="#MathOptInterface.getconstraintaffine"><code>MathOptInterface.getconstraintaffine</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintaffine(m::AbstractModel, c::ConstraintReference)</code></pre><p>Return the <span>$A$</span> matrix of the constraint corresponding to <code>c</code> in triplet form <code>(row,varref,coef)</code> where <code>row</code> is an integer, <code>varref</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of three vectors.</p><pre><code class="language-none">getconstraintaffine(m::AbstractModel, c::ConstraintReference, i::Int)</code></pre><p>Return the <code>i</code>th row of the <span>$A$</span> matrix of the constraint corresponding to <code>c</code> in tuple form <code>(varref,coef)</code> where <code>varref</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of two vectors.</p><pre><code class="language-none">getconstraintaffine(m::AbstractModel, c::ConstraintReference, i::Int, v::VariableReference)</code></pre><p>Return the element of the <span>$A$</span> matrix of the constraint corresponding to <code>c</code> in row <code>i</code> and variable <code>v</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/constraints.jl#L161-L173">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getconstraintquadratic" href="#MathOptInterface.getconstraintquadratic"><code>MathOptInterface.getconstraintquadratic</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconstraintquadratic(m::AbstractModel, c::ConstraintReference, i::Int)</code></pre><p>Return the <span>$Q$</span> matrix of the <code>i</code>th row of the constraint corresponding to <code>c</code> in triplet form <code>(varref_a,varref_b,coef)</code> where <code>varref_a</code> is a <code>VariableReference</code>, <code>varref_b</code> is a <code>VariableReference</code>, and <code>coef</code> is a coefficient. Output is a tuple of three vectors. The <span>$Q$</span> matrix must be symmetric, and only one of the two symmetric elements is returned.</p><pre><code class="language-none">getconstraintquadratic(m::AbstractModel, c::ConstraintReference, i::Int, v1::VariableReference, v2::VariableReference)</code></pre><p>Return the element <code>(v1,v2)</code> of the <span>$Q$</span> matrix of the <code>i</code>th row of the constraint corresponding to <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/constraints.jl#L176-L184">source</a><br/></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>List of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSet" href="#MathOptInterface.AbstractSet"><code>MathOptInterface.AbstractSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSet</code></pre><p>Abstract supertype for set objects used to encode constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L1-L5">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Reals" href="#MathOptInterface.Reals"><code>MathOptInterface.Reals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Reals(dim)</code></pre><p>The set <span>$\mathbb{R}^{dim}$</span> (containing all points) of dimension <span>$dim$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L15-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Zeros" href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zeros(dim)</code></pre><p>The set <span>$\{ 0 \}^{dim}$</span> (containing only the origin) of dimension <span>$dim$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L24-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NonNegatives" href="#MathOptInterface.NonNegatives"><code>MathOptInterface.NonNegatives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NonNegatives(dim)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dim} : x \ge 0 \}$</span> of dimension <span>$dim$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L33-L37">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NonPositives" href="#MathOptInterface.NonPositives"><code>MathOptInterface.NonPositives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NonPositives(dim)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^{dim} : x \le 0 \}$</span> of dimension <span>$dim$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L42-L46">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GreaterThan" href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GreaterThan(lower)</code></pre><p>The set <span>$[lower,\infty) \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L51-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LessThan" href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LessThan(upper)</code></pre><p>The set <span>$(-\infty,upper] \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L60-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Interval" href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Interval(lower,upper)</code></pre><p>The interval <span>$[lower, upper] \subseteq \mathbb{R}$</span>. If <span>$lower$</span> or <span>$upper$</span> is <span>$-Inf$</span> or <span>$Inf$</span>, respectively, the set is interpreted as a one-sided interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L69-L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SecondOrderCone" href="#MathOptInterface.SecondOrderCone"><code>MathOptInterface.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SecondOrderCone(dim)</code></pre><p>The second-order cone (or Lorenz cone) <span>$\{ (t,x) \in \mathbb{R}^{dim} : t \ge || x ||_2 \}$</span> of dimension <span>$dim$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L81-L85">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ExponentialCone" href="#MathOptInterface.ExponentialCone"><code>MathOptInterface.ExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialCone()</code></pre><p>The 3-dimensional exponential cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L90-L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualExponentialCone" href="#MathOptInterface.DualExponentialCone"><code>MathOptInterface.DualExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualExponentialCone()</code></pre><p>The 3-dimensional dual exponential cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le \exp(1) w, u &lt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L98-L102">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PowerCone" href="#MathOptInterface.PowerCone"><code>MathOptInterface.PowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PowerCone(a)</code></pre><p>The 3-dimensional power cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^{a} y^{1-a} &gt;= |z|, x \ge 0, y \ge 0 \}$</span> with parameter <span>$a$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L106-L110">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualPowerCone" href="#MathOptInterface.DualPowerCone"><code>MathOptInterface.DualPowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualPowerCone(a)</code></pre><p>The 3-dimensional power cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : (u/a)^a (v/(1-a))^{1-a} &gt;= |w|, u \ge 0, v \ge 0 \}$</span> with parameter <span>$a$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L115-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeTriangle" href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeTriangle(dim)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals unscaled. The entries of the upper triangular part of the matrix are given row by row (or equivalently, the entries of the lower triangular part are given column by column). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <span>$dim$</span>, the corresponding symmetric matrix has side dimension <span>$\sqrt (1/4 + 2 dim) - 1/2$</span> elements. The scalar product is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 3\\
  2 &amp; 4 &amp; 5\\
  3 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>corresponds to <span>$(1, 2, 3, 4, 5, 6)$</span> for <code>PositiveSemidefiniteConeTriangle</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L126-L145">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeScaled" href="#MathOptInterface.PositiveSemidefiniteConeScaled"><code>MathOptInterface.PositiveSemidefiniteConeScaled</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeScaled(dim)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals scaled. The entries of the upper triangular part of the matrix are given row by row (or equivalently, the entries of the lower triangular part are given column by column). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <span>$dim$</span>, the corresponding symmetric matrix has side dimension <span>$\sqrt (1/4 + 2 dim) - 1/2$</span> elements. The off-diagonal entries of the matrices of both the cone and its dual are scaled by <span>$\sqrt{2}$</span> and the scalar product is simply the sum of the pairwise product of the entries.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 3\\
  2 &amp; 4 &amp; 5\\
  3 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>and to <span>$(1, 2\sqrt{2}, 3\sqrt{2}, 4, 5\sqrt{2}, 6)$</span> for <code>PositiveSemidefiniteConeScaled</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L150-L169">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Integers" href="#MathOptInterface.Integers"><code>MathOptInterface.Integers</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Integers()</code></pre><p>The set of integers <span>$\mathbb{Z}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L174-L178">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ZeroOne" href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ZeroOne()</code></pre><p>The set <span>$\{ 0, 1 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L181-L185">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS1" href="#MathOptInterface.SOS1"><code>MathOptInterface.SOS1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS1(weights)</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <span>$weights$</span> induce an ordering of the variables; as such, they should be unique values. The <span>$k$</span>-th element in the set corresponds to the <span>$k$</span>-th weight in <span>$weights$</span>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L190-L194">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS2" href="#MathOptInterface.SOS2"><code>MathOptInterface.SOS2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS2(weights)</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <span>$weights$</span> induce an ordering of the variables; as such, they should be unique values. The <span>$k$</span>-th element in the set corresponds to the <span>$k$</span>-th weight in <span>$weights$</span>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L199-L203">source</a><br/></section><p>Functions for getting and setting properties of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.dimension" href="#MathOptInterface.dimension"><code>MathOptInterface.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dimension(s::AbstractSet)</code></pre><p>Return the dimension (number of vector components) in the set <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/sets.jl#L8-L12">source</a><br/></section><h2><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h2><h3><a class="nav-anchor" id="Solver-or-Model-Attributes-1" href="#Solver-or-Model-Attributes-1">Solver or Model Attributes</a></h3><p>List of solver or model attributes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ReturnsDuals" href="#MathOptInterface.ReturnsDuals"><code>MathOptInterface.ReturnsDuals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ReturnsDuals()</code></pre><p>A <code>Bool</code> indicating if the solver should be expected to return dual solutions when appropriate. A solver attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L159-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAddConstraintAfterSolve" href="#MathOptInterface.SupportsAddConstraintAfterSolve"><code>MathOptInterface.SupportsAddConstraintAfterSolve</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAddConstraintAfterSolver()</code></pre><p>A <code>Bool</code> indicating if the solver supports adding constraints after a solve. If <code>false</code>, then a new model should be constructed instead. A solver attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L167-L173">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsDeleteConstraint" href="#MathOptInterface.SupportsDeleteConstraint"><code>MathOptInterface.SupportsDeleteConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsDeleteConstraint()</code></pre><p>A <code>Bool</code> indicating if the solver supports deleting constraints from a model. A solver attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L176-L181">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAddVariableAfterSolver" href="#MathOptInterface.SupportsAddVariableAfterSolver"><code>MathOptInterface.SupportsAddVariableAfterSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAddVariableAfterSolve()</code></pre><p>A <code>Bool</code> indicating if the solver supports adding variables after a solve. In the context of linear programming, this is known as column generation. A solver attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L192-L198">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsQuadraticObjective" href="#MathOptInterface.SupportsQuadraticObjective"><code>MathOptInterface.SupportsQuadraticObjective</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsQuadraticObjective()</code></pre><p>A <code>Bool</code> indicating if the solver supports quadratic objectives. A solver attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L205-L210">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsConicThroughQuadratic" href="#MathOptInterface.SupportsConicThroughQuadratic"><code>MathOptInterface.SupportsConicThroughQuadratic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsConicThroughQuadratic()</code></pre><p>A <code>Bool</code> indicating if the solver interprets certain quadratic constraints as second-order cone constraints. A solver attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L213-L218">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveValue(resultidx::Int=1, objectiveindex::Int=1)</code></pre><p>The objective value of the <code>resultindex</code>&#39;th primal result of the <code>objectiveindex</code>&#39;th objective. A model attribute.</p><p>Both <code>resultindex</code> and <code>objectiveindex</code> default to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L221-L227">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveBound()</code></pre><p>The best known bound on the optimal objective value. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L234-L238">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RelativeGap()</code></pre><p>The final relative optimality gap as optimization terminated. That is, <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L241-L245">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolveTime()</code></pre><p>The total elapsed solution time (in seconds) as reported by the solver. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L248-L252">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Sense" href="#MathOptInterface.Sense"><code>MathOptInterface.Sense</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Sense()</code></pre><p>The optimization sense of the model, an <code>OptimizationSense</code> with value <code>MinSense</code> or <code>MaxSense</code>. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L255-L259">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SimplexIterations()</code></pre><p>The cumulative number of simplex iterations during the optimization process. In particular, for a MIP the total simplex iterations for all nodes. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L264-L268">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BarrierIterations()</code></pre><p>The cumulative number of barrier iterations during the optimization process. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L271-L275">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NodeCount()</code></pre><p>The total number of branch-and-bound nodes explored. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L278-L282">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RawSolver()</code></pre><p>An object that may be used to access a solver-specific API for this model. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L285-L289">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultCount()</code></pre><p>The number of results available. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L292-L296">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfVariables()</code></pre><p>The number of variables in the model. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L299-L303">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariablewiseConstraints" href="#MathOptInterface.NumberOfVariablewiseConstraints"><code>MathOptInterface.NumberOfVariablewiseConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfVariablewiseConstraints{T}()</code></pre><p>The number of variablewise constraints of type T in the model. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L306-L310">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfAffineConstraints" href="#MathOptInterface.NumberOfAffineConstraints"><code>MathOptInterface.NumberOfAffineConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfAffineConstraints{T}()</code></pre><p>The number of affine constraints of type T in the model. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L313-L317">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfQuadraticConstraints" href="#MathOptInterface.NumberOfQuadraticConstraints"><code>MathOptInterface.NumberOfQuadraticConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfQuadraticConstraints{T}()</code></pre><p>The number of quadratic constraints of type T in the model. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L320-L324">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsVariablewiseConstraint" href="#MathOptInterface.SupportsVariablewiseConstraint"><code>MathOptInterface.SupportsVariablewiseConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsVariablewiseConstraint{T}()</code></pre><p>A <code>Bool</code> indicating whether the solver or model supports a variablewise constraint in the set <span>$S$</span> which is a set of type <code>T</code>. A solver and model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L328-L334">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAffineConstraint" href="#MathOptInterface.SupportsAffineConstraint"><code>MathOptInterface.SupportsAffineConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAffineConstraint{T}()</code></pre><p>A <code>Bool</code> indicating whether the solver or model supports a constraint of of the form &quot;affine expression&quot; in <span>$S$</span> where <span>$S$</span> is a set of type <code>T</code>. A solver and model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L337-L343">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsQuadraticConstraint" href="#MathOptInterface.SupportsQuadraticConstraint"><code>MathOptInterface.SupportsQuadraticConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsQuadraticConstraint{T}()</code></pre><p>A <code>Bool</code> indicating whether the solver or model supports a constraint of of the form &quot;quadratic expression&quot; in <span>$S$</span> where <span>$S$</span> is a set of type <code>T</code>. A solver and model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L346-L352">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatus()</code></pre><p>A <code>TerminationStatusCode</code> explaining why the solver stopped. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L448-L452">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PrimalStatus(N)
PrimalStatus()</code></pre><p>The <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L509-L514">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualStatus(N)
DualStatus()</code></pre><p>The <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1. A model attribute.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L520-L525">source</a><br/></section><p>Functions for getting and setting model or solver attributes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverOrModelAttribute" href="#MathOptInterface.AbstractSolverOrModelAttribute"><code>MathOptInterface.AbstractSolverOrModelAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverOrModelAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the model or solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L1-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractVariableAttribute" href="#MathOptInterface.AbstractVariableAttribute"><code>MathOptInterface.AbstractVariableAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractVariableAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L10-L15">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractConstraintAttribute" href="#MathOptInterface.AbstractConstraintAttribute"><code>MathOptInterface.AbstractConstraintAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractConstraintAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L18-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cangetattribute" href="#MathOptInterface.cangetattribute"><code>MathOptInterface.cangetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cangetattribute(s::AbstractSolver, attr::AbstractSolverOrModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to query attribute <code>attr</code> from the solver <code>s</code>.</p><pre><code class="language-none">cangetattribute(m::AbstractModel, attr::AbstractVariableAttribute, R::Type{VariableReference})::Bool
cangetattribute(m::AbstractModel, attr::AbstractConstraintAttribute, R::Type{VariablewiseConstraintReference{T})::Bool
cangetattribute(m::AbstractModel, attr::AbstractConstraintAttribute, R::Type{AffineConstraintReference{T})::Bool
cangetattribute(m::AbstractModel, attr::AbstractConstraintAttribute, R::Type{QuadraticConstraintReference{T})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the model <code>m</code> currently has a value for the attributed specified by attribute type <code>attr</code> applied to the reference type <code>R</code>.</p><p><strong>Examples</strong></p><p>```julia cangetattribute(GurobiSolver(), SupportsAffineConstraint{Zero}()) cangetattribute(m, ObjectiveValue()) cangetattribute(m, VariablePrimalStart(), varref) cangetattribute(m, ConstraintPrimal(), conref)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L80-L99">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getattribute" href="#MathOptInterface.getattribute"><code>MathOptInterface.getattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute(s::AbstractSolver, attr::AbstractSolverOrModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the solver <code>s</code>.</p><pre><code class="language-none">getattribute(m::AbstractModel, attr::AbstractSolverOrModelAttribute)</code></pre><p>Return an attribute <code>attr</code> of the model <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractModel, attr::AbstractVariableAttribute, v::VariableReference)</code></pre><p>Return an attribute <code>attr</code> of the variable <code>v</code> in model <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractModel, attr::AbstractVariableAttribute, v::Vector{VariableReference})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the model <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractModel, attr::AbstractConstraintAttribute, c::ConstraintReference)</code></pre><p>Return an attribute <code>attr</code> of the constraint <code>c</code> in model <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractModel, attr::AbstractConstraintAttribute, c::Vector{VariablewiseConstraintReference{T}})
getattribute(m::AbstractModel, attr::AbstractConstraintAttribute, c::Vector{AffineConstraintReference{T}})
getattribute(m::AbstractModel, attr::AbstractConstraintAttribute, c::Vector{QuadraticConstraintReference{T}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the model <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">getattribute(m, ObjectiveValue())
getattribute(m, VariableResult(), ref)
getattribute(m, VariableResult(5), [ref1,ref2])
getattribute(m, OtherAttribute(&quot;something specific to cplex&quot;))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L28-L63">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getattribute!" href="#MathOptInterface.getattribute!"><code>MathOptInterface.getattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute!(output, m::AbstractModel, args...)</code></pre><p>An in-place version of <code>getattribute</code>. The signature matches that of <code>getattribute</code> except that the the result is placed in the vector <code>output</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L70-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cansetattribute" href="#MathOptInterface.cansetattribute"><code>MathOptInterface.cansetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cansetattribute(s::AbstractSolver, attr::AbstractSolverOrModelAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> in the solver <code>s</code>.</p><pre><code class="language-none">cansetattribute(m::AbstractModel, attr::AbstractVariableAttribute, R::Type{VariableReference})::Bool
cansetattribute(m::AbstractModel, attr::AbstractConstraintAttribute, R::Type{VariablewiseConstraintReference{T})::Bool
cangetattribute(m::AbstractModel, attr::AbstractConstraintAttribute, R::Type{AffineConstraintReference{T})::Bool
cangetattribute(m::AbstractModel, attr::AbstractConstraintAttribute, R::Type{QuadraticConstraintReference{T})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> applied to the reference type <code>R</code> in the model <code>m</code>.</p><p><strong>Examples</strong></p><p>```julia cansetattribute(GurobiSolver(), SupportsAffineConstraint{Zero}()) cansetattribute(m, ObjectiveValue()) cansetattribute(m, VariablePrimalStart(), VariableReference) cansetattribute(m, ConstraintPrimal(), AffineConstraintReference{NonNegative})</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L103-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.setattribute!" href="#MathOptInterface.setattribute!"><code>MathOptInterface.setattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setattribute!(s::AbstractSolver, attr::AbstractSolverOrModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the solver <code>s</code>.</p><pre><code class="language-none">setattribute!(m::AbstractModel, attr::AbstractSolverOrModelAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the model <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractModel, attr::AbstractVariableAttribute, v::VariableReference, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in model <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractModel, attr::AbstractVariableAttribute, v::Vector{VariableReference}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in model <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractModel, attr::AbstractConstraintAttribute, c::ConstraintReference, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in model <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractModel, attr::AbstractConstraintAttribute, c::Vector{VariablewiseConstraintReference{T}})
setattribute!(m::AbstractModel, attr::AbstractConstraintAttribute, c::Vector{AffineConstraintReference{T}})
setattribute!(m::AbstractModel, attr::AbstractConstraintAttribute, c::Vector{QuadraticConstraintReference{T}})</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in model <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L125-L151">source</a><br/></section><h3><a class="nav-anchor" id="Variable-Attributes-1" href="#Variable-Attributes-1">Variable Attributes</a></h3><p>List of attributes associated with variables. Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>VariableReference</code> or a vector of <code>VariableReference</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimalStart" href="#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimalStart()</code></pre><p>An initial assignment of the variables that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L359-L364">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimal" href="#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimal(N)
VariablePrimal()</code></pre><p>The assignment to the primal variables in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L367-L372">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableBasisStatus" href="#MathOptInterface.VariableBasisStatus"><code>MathOptInterface.VariableBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given variable, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L378-L382">source</a><br/></section><h3><a class="nav-anchor" id="Constraint-Attributes-1" href="#Constraint-Attributes-1">Constraint Attributes</a></h3><p>List of attributes associated with constraints. Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>ConstraintReference</code> or a vector of <code>ConstriaintReference{T}</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimalStart" href="#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimalStart()</code></pre><p>An initial assignment of the constraint primal values that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L399-L404">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDualStart" href="#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDualStart()</code></pre><p>An initial assignment of the constriant duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L407-L412">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimal" href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>The assignment to the constraint primal values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L415-L420">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDual" href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDual(N)
ConstraintDual()</code></pre><p>The assignment to the constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L426-L431">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintBasisStatus" href="#MathOptInterface.ConstraintBasisStatus"><code>MathOptInterface.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given constraint, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L437-L441">source</a><br/></section><h2><a class="nav-anchor" id="Status-Codes-1" href="#Status-Codes-1">Status Codes</a></h2><h3><a class="nav-anchor" id="Termination-Status-1" href="#Termination-Status-1">Termination Status</a></h3><p>The <code>TerminationStatus</code> attribute is meant to explain the reason why the solver stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the solver stopped executing.</p><p><strong>OK</strong></p><p>These are generally OK statuses.</p><ul><li><p><code>Success</code>: the algorithm ran successfully and has a result. This includes cases where the algorithm converges to an infeasible point (NLP) or converges to a solution of a homogeneous self-dual problem and has a certificate of primal/dual infeasibility.</p></li><li><p><code>AlmostSuccess</code>: the algorithm <em>almost</em> ran successfully (e.g., to relaxed convergence tolerances) and has a result.</p></li><li><p><code>InfeasibleNoResult</code>: the algorithm stopped because it decided that the problem is infeasible but does not have a result to return.</p></li><li><p><code>UnboundedNoResult</code>: the algorithm stopped because it decided that the problem is unbounded but does not have a result to return.</p></li><li><p><code>InfeasibleOrUnbounded</code>: the algorithm stopped because it decided that the problem is infeasible or unbounded; no result is available. This occasionally happens during MIP presolve.</p></li></ul><p><strong>Limits</strong></p><p>The solver stopped because of some user-defined limit. To be documented: <code>IterationLimit</code>, <code>TimeLimit</code>, <code>NodeLimit</code>, <code>SolutionLimit</code>, <code>MemoryLimit</code>, <code>ObjectiveLimit</code>, <code>NormLimit</code>, <code>OtherLimit</code>.</p><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><p><code>SlowProgress</code>: the algorithm stopped because it was unable to continue making progress towards the solution. <code>AlmostSuccess</code> should be used if there is additional information that relaxed convergence tolerances are satisfied.</p></li></ul><p>To be documented: <code>NumericalError</code>, <code>InvalidModel</code>, <code>InvalidOption</code>, <code>Interrupted</code>, <code>OtherError</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L455-L487">source</a><br/></section><h3><a class="nav-anchor" id="Result-Status-1" href="#Result-Status-1">Result Status</a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes are meant to explain how to interpret the result returned by the solver. The value of the attributes are of type <code>ResultStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><p><code>FeasiblePoint</code></p></li><li><p><code>NearlyFeasiblePoint</code></p></li><li><p><code>InfeasiblePoint</code></p></li><li><p><code>InfeasibilityCertificate</code></p></li><li><p><code>NearlyInfeasibilityCertificate</code></p></li><li><p><code>ReductionCertificate</code></p></li><li><p><code>NearlyReductionCertificate</code></p></li><li><p><code>Unknown</code></p></li><li><p><code>Other</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L492-L506">source</a><br/></section><h3><a class="nav-anchor" id="Basis-Status-1" href="#Basis-Status-1">Basis Status</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BasisStatusCode" href="#MathOptInterface.BasisStatusCode"><code>MathOptInterface.BasisStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>VariableBasisStatus</code> and <code>ConstraintBasisStatus</code> attribute. This explains the status of a given element with respect to an optimal solution basis. Possible values are:     * <code>Basic</code>: element is in the basis.     * <code>Nonbasic</code>: element is not in the basis.     * <code>NonbasicAtLower</code>: element is not in the basis and is at its lower bound.     * <code>NonbasicAtUpper</code>: element is not in the basis and is at its upper bound.     * <code>SuperBasic</code>: element is not in the basis but is also not at one of its bounds.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/d65a603c3bf8099f5c0996828aa57d889d59f3de/src/attributes.jl#L385-L394">source</a><br/></section><footer><hr/><a class="previous" href="apimanual.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
