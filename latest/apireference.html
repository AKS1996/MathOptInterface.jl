<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="apimanual.html">Manual</a></li><li class="current"><a class="toctext" href="apireference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#Attributes-1">Attributes</a></li><li><a class="toctext" href="#Solver-1">Solver</a></li><li><a class="toctext" href="#Solver-Instance-1">Solver Instance</a></li><li><a class="toctext" href="#Variables-and-Constraints-1">Variables and Constraints</a></li><li><a class="toctext" href="#Functions-and-function-modifications-1">Functions and function modifications</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Objectives-1">Objectives</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><p>[Some introduction to API. List basic standalone methods.]</p><h2><a class="nav-anchor" id="Attributes-1" href="#Attributes-1">Attributes</a></h2><p>List of attribute categories.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverAttribute" href="#MathOptInterface.AbstractSolverAttribute"><code>MathOptInterface.AbstractSolverAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverInstanceAttribute" href="#MathOptInterface.AbstractSolverInstanceAttribute"><code>MathOptInterface.AbstractSolverInstanceAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverInstanceAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L10-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractVariableAttribute" href="#MathOptInterface.AbstractVariableAttribute"><code>MathOptInterface.AbstractVariableAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractVariableAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of variables in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L17-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractConstraintAttribute" href="#MathOptInterface.AbstractConstraintAttribute"><code>MathOptInterface.AbstractConstraintAttribute</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractConstraintAttribute</code></pre><p>Abstract supertype for attribute objects that can be used to set or get attributes (properties) of constraints in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L24-L28">source</a><br/></section><p>Functions for getting and setting attributes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cangetattribute" href="#MathOptInterface.cangetattribute"><code>MathOptInterface.cangetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cangetattribute(s::AbstractSolver, attr::AbstractSolverAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to query attribute <code>attr</code> from the solver <code>s</code>.</p><pre><code class="language-none">cangetattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::VariableReference)::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::ConstraintReference{F,S})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the solver instance <code>m</code> currently has a value for the attributed specified by attribute type <code>attr</code> applied to the variable reference <code>v</code> or constraint reference <code>c</code>.</p><pre><code class="language-none">cangetattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::Vector{VariableReference})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{ConstraintReference{F,S}})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether the solver instance <code>m</code> currently has a value for the attributed specified by attribute type <code>attr</code> applied to <em>every</em> variable references in <code>v</code> or constraint reference in <code>c</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">cangetattribute(m, ObjectiveValue())
cangetattribute(m, VariablePrimalStart(), varref)
cangetattribute(m, ConstraintPrimal(), conref)
cangetattribute(m, VariablePrimal(), [ref1, ref2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L84-L107">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getattribute" href="#MathOptInterface.getattribute"><code>MathOptInterface.getattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute(s::AbstractSolver, attr::AbstractSolverAttribute)</code></pre><p>Return an attribute <code>attr</code> of the solver <code>s</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractSolverInstanceAttribute)</code></pre><p>Return an attribute <code>attr</code> of the solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::VariableReference)</code></pre><p>Return an attribute <code>attr</code> of the variable <code>v</code> in solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::Vector{VariableReference})</code></pre><p>Return a vector of attributes corresponding to each variable in the collection <code>v</code> in the solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::ConstraintReference)</code></pre><p>Return an attribute <code>attr</code> of the constraint <code>c</code> in solver instance <code>m</code>.</p><pre><code class="language-none">getattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{ConstraintReference{F,S}})</code></pre><p>Return a vector of attributes corresponding to each constraint in the collection <code>c</code> in the solver instance <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">getattribute(m, ObjectiveValue())
getattribute(m, VariablePrimal(), ref)
getattribute(m, VariablePrimal(5), [ref1, ref2])
getattribute(m, OtherAttribute(&quot;something specific to cplex&quot;))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L33-L66">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.getattribute!" href="#MathOptInterface.getattribute!"><code>MathOptInterface.getattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getattribute!(output, m::AbstractSolverInstance, args...)</code></pre><p>An in-place version of <code>getattribute</code>. The signature matches that of <code>getattribute</code> except that the the result is placed in the vector <code>output</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L73-L78">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cansetattribute" href="#MathOptInterface.cansetattribute"><code>MathOptInterface.cansetattribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cansetattribute(s::AbstractSolver, attr::AbstractSolverAttribute)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> in the solver <code>s</code>.</p><pre><code class="language-none">cansetattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, R::Type{VariableReference})::Bool
cangetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, R::Type{ConstraintReference{F,S})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code> applied to the reference type <code>R</code> in the solver instance <code>m</code>.</p><pre><code class="language-none">cansetattribute(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::Vector{VariableReference})::Bool
cansetattribute(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{ConstraintReference{F,S}})::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to set attribute <code>attr</code>applied to <em>every</em> variable reference in <code>v</code> or constraint reference in <code>c</code> in the solver instance <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">cansetattribute(m, ObjectiveValue())
cansetattribute(m, VariablePrimalStart(), VariableReference)
cansetattribute(m, ConstraintPrimal(), ConstraintReference{VectorAffineFunction{Float64},Nonnegatives})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L113-L135">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.setattribute!" href="#MathOptInterface.setattribute!"><code>MathOptInterface.setattribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setattribute!(s::AbstractSolver, attr::AbstractSolverAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the solver <code>s</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractSolverInstanceAttribute, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of the solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::VariableReference, value)</code></pre><p>Assign <code>value</code> to the attribute <code>attr</code> of variable <code>v</code> in solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractVariableAttribute, v::Vector{VariableReference}, vector_of_values)</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each variable in the collection <code>v</code> in solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::ConstraintReference, value)</code></pre><p>Assign a value to the attribute <code>attr</code> of constraint <code>c</code> in solver instance <code>m</code>.</p><pre><code class="language-none">setattribute!(m::AbstractSolverInstance, attr::AbstractConstraintAttribute, c::Vector{ConstraintReference{F,S}})</code></pre><p>Assign a value respectively to the attribute <code>attr</code> of each constraint in the collection <code>c</code> in solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L141-L165">source</a><br/></section><h2><a class="nav-anchor" id="Solver-1" href="#Solver-1">Solver</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolver" href="#MathOptInterface.AbstractSolver"><code>MathOptInterface.AbstractSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolver</code></pre><p>Abstract supertype for &quot;solver&quot; objects. A solver is a lightweight object used for selecting solvers and parameters. It does not store any solver instance data.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/MathOptInterface.jl#L4-L10">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.supportsproblem" href="#MathOptInterface.supportsproblem"><code>MathOptInterface.supportsproblem</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">supportsproblem(s::AbstractSolver, objective_type::F, constraint_types::Vector)::Bool</code></pre><p>Return <code>true</code> if the solver supports optimizing a problem with objective type <code>F</code> and constraints of the types specified by <code>constraint_types</code> which is a list of tuples <code>(F,S)</code> for <code>F</code>-in-<code>S</code> constraints. Return false if the solver does not support this problem class.</p><p><strong>Examples</strong></p><pre><code class="language-julia">supportsproblem(s, ScalarAffineFunction{Float64},
    [(ScalarAffineFunction{Float64},Zeros),
    (ScalarAffineFunction{Float64},LessThan),
    (ScalarAffineFunction{Float64},GreaterThan)])</code></pre><p>should be <code>true</code> for a linear programming solver <code>s</code>.</p><pre><code class="language-julia">supportsproblem(s, ScalarQuadraticFunction{Float64},
    [(ScalarAffineFunction{Float64},Zeros),
    (ScalarAffineFunction{Float64},LessThan),
    (ScalarAffineFunction{Float64},GreaterThan)])</code></pre><p>should be <code>true</code> for a quadratic programming solver <code>s</code>.</p><pre><code class="language-julia">supportsproblem(s, ScalarAffineFunction{Float64},
    [(ScalarAffineFunction{Float64},Zeros),
    (ScalarAffineFunction{Float64},LessThan),
    (ScalarAffineFunction{Float64},GreaterThan),
    (SingleVariable,ZeroOne)])</code></pre><p>should be <code>true</code> for a mixed-integer linear programming solver <code>s</code>.</p><pre><code class="language-julia">supportsproblem(s, ScalarAffineFunction{Float64},
    [(ScalarAffineFunction{Float64},Zeros),
    (ScalarAffineFunction{Float64},LessThan),
    (ScalarAffineFunction{Float64},GreaterThan),
    (VectorAffineFunction{Float64},SecondOrderCone)])</code></pre><p>should be <code>true</code> for a second-order cone solver <code>s</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/MathOptInterface.jl#L52-L93">source</a><br/></section><p>List of solver attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsDuals" href="#MathOptInterface.SupportsDuals"><code>MathOptInterface.SupportsDuals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsDuals()</code></pre><p>A <code>Bool</code> indicating if the solver should be expected to return dual solutions when appropriate.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L173-L177">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAddConstraintAfterSolve" href="#MathOptInterface.SupportsAddConstraintAfterSolve"><code>MathOptInterface.SupportsAddConstraintAfterSolve</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAddConstraintAfterSolve()</code></pre><p>A <code>Bool</code> indicating if the solver supports adding constraints after a solve. If <code>false</code>, then a new solver instance should be constructed instead.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L180-L185">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsDeleteConstraint" href="#MathOptInterface.SupportsDeleteConstraint"><code>MathOptInterface.SupportsDeleteConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsDeleteConstraint()</code></pre><p>A <code>Bool</code> indicating if the solver supports deleting constraints from a solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L188-L192">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsDeleteVariable" href="#MathOptInterface.SupportsDeleteVariable"><code>MathOptInterface.SupportsDeleteVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsDeleteVariable()</code></pre><p>A <code>Bool</code> indicating if the solver supports deleting variables from a solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L195-L199">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsAddVariableAfterSolve" href="#MathOptInterface.SupportsAddVariableAfterSolve"><code>MathOptInterface.SupportsAddVariableAfterSolve</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsAddVariableAfterSolve()</code></pre><p>A <code>Bool</code> indicating if the solver supports adding variables after a solve. In the context of linear programming, this is known as column generation.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L202-L207">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SupportsConicThroughQuadratic" href="#MathOptInterface.SupportsConicThroughQuadratic"><code>MathOptInterface.SupportsConicThroughQuadratic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SupportsConicThroughQuadratic()</code></pre><p>A <code>Bool</code> indicating if the solver interprets certain quadratic constraints as second-order cone constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L214-L218">source</a><br/></section><h2><a class="nav-anchor" id="Solver-Instance-1" href="#Solver-Instance-1">Solver Instance</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSolverInstance" href="#MathOptInterface.AbstractSolverInstance"><code>MathOptInterface.AbstractSolverInstance</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolverInstance</code></pre><p>Abstract supertype which represents a solver&#39;s in-memory representation of an optimization problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/MathOptInterface.jl#L13-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolverInstance" href="#MathOptInterface.SolverInstance"><code>MathOptInterface.SolverInstance</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">SolverInstance(solver::AbstractSolver)</code></pre><p>Create a solver instance from the given solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/MathOptInterface.jl#L20-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.optimize!" href="#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">optimize!(m::AbstractSolverInstance)</code></pre><p>Start the solution procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/MathOptInterface.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.free!" href="#MathOptInterface.free!"><code>MathOptInterface.free!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">free!(m::AbstractSolverInstance)</code></pre><p>Release any resources and memory used by the solver instance. Note that the Julia garbage collector takes care of this automatically, but automatic collection cannot always be forced. This method is useful for more precise control of resources, especially in the case of commercial solvers with licensing restrictions on the number of concurrent runs. Users must discard the solver instance object after this method is invoked.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/MathOptInterface.jl#L34-L41">source</a><br/></section><p>List of solver instance attributes</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RawSolver" href="#MathOptInterface.RawSolver"><code>MathOptInterface.RawSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RawSolver()</code></pre><p>An object that may be used to access a solver-specific API for this solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L285-L289">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveSense" href="#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveSense()</code></pre><p>The sense of the objective function, an <code>OptimizationSense</code> with value <code>MinSense</code>, <code>MaxSense</code>, or <code>FeasiblitySense</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L254-L258">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfVariables" href="#MathOptInterface.NumberOfVariables"><code>MathOptInterface.NumberOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfVariables()</code></pre><p>The number of variables in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L299-L303">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfVariableReferences" href="#MathOptInterface.ListOfVariableReferences"><code>MathOptInterface.ListOfVariableReferences</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfVariableReferences()</code></pre><p>A <code>Vector{VariableReference}</code> with references to all variables present in the solver instance (i.e., of length equal to the value of <code>NumberOfVariables()</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L306-L311">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraints" href="#MathOptInterface.ListOfConstraints"><code>MathOptInterface.ListOfConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfConstraints()</code></pre><p>A list of tuples of the form <code>(F,S)</code>, where <code>F</code> is a function type and <code>S</code> is a set type indicating that the attribute <code>NumberOfConstraints{F,S}()</code> has value greater than zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L329-L335">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NumberOfConstraints" href="#MathOptInterface.NumberOfConstraints"><code>MathOptInterface.NumberOfConstraints</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NumberOfConstraints{F,S}()</code></pre><p>The number of constraints of the type <code>F</code>-in-<code>S</code> present in the solver instance.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L322-L326">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ListOfConstraintReferences" href="#MathOptInterface.ListOfConstraintReferences"><code>MathOptInterface.ListOfConstraintReferences</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ListOfConstraintReferences{F,S}()</code></pre><p>A <code>Vector{ConstraintReferences{F,S}}</code> with references to all constraints of type <code>F</code>-in<code>S</code> in the solver instance (i.e., of length equal to the value of <code>NumberOfConstraints{F,S}()</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L314-L319">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultCount" href="#MathOptInterface.ResultCount"><code>MathOptInterface.ResultCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultCount()</code></pre><p>The number of results available.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L292-L296">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveFunction" href="#MathOptInterface.ObjectiveFunction"><code>MathOptInterface.ObjectiveFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveFunction()</code></pre><p>An <code>AbstractFunction</code> instance which represents the objective function. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L338-L343">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveValue" href="#MathOptInterface.ObjectiveValue"><code>MathOptInterface.ObjectiveValue</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveValue(resultidx::Int=1)</code></pre><p>The objective value of the <code>resultindex</code>th primal result.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L223-L227">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ObjectiveBound" href="#MathOptInterface.ObjectiveBound"><code>MathOptInterface.ObjectiveBound</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ObjectiveBound()</code></pre><p>The best known bound on the optimal objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L233-L237">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RelativeGap" href="#MathOptInterface.RelativeGap"><code>MathOptInterface.RelativeGap</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RelativeGap()</code></pre><p>The final relative optimality gap, defined as <span>$\frac{|b-f|}{|f|}$</span>, where <span>$b$</span> is the best bound and <span>$f$</span> is the best feasible objective value.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L240-L244">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SolveTime" href="#MathOptInterface.SolveTime"><code>MathOptInterface.SolveTime</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SolveTime()</code></pre><p>The total elapsed solution time (in seconds) as reported by the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L247-L251">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SimplexIterations" href="#MathOptInterface.SimplexIterations"><code>MathOptInterface.SimplexIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SimplexIterations()</code></pre><p>The cumulative number of simplex iterations during the optimization process. In particular, for a mixed-integer program (MIP), the total simplex iterations for all nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L263-L268">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BarrierIterations" href="#MathOptInterface.BarrierIterations"><code>MathOptInterface.BarrierIterations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BarrierIterations()</code></pre><p>The cumulative number of barrier iterations while solving a problem.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L271-L275">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.NodeCount" href="#MathOptInterface.NodeCount"><code>MathOptInterface.NodeCount</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NodeCount()</code></pre><p>The total number of branch-and-bound nodes explored while solving a mixed-integer program (MIP).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L278-L282">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatus" href="#MathOptInterface.TerminationStatus"><code>MathOptInterface.TerminationStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatus()</code></pre><p>A <code>TerminationStatusCode</code> explaining why the solver stopped.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L450-L454">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PrimalStatus" href="#MathOptInterface.PrimalStatus"><code>MathOptInterface.PrimalStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PrimalStatus(N)
PrimalStatus()</code></pre><p>The <code>ResultStatusCode</code> of the primal result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L509-L515">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualStatus" href="#MathOptInterface.DualStatus"><code>MathOptInterface.DualStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualStatus(N)
DualStatus()</code></pre><p>The <code>ResultStatusCode</code> of the dual result <code>N</code>. If <code>N</code> is omitted, it defaults to 1.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L521-L527">source</a><br/></section><h3><a class="nav-anchor" id="Termination-Status-1" href="#Termination-Status-1">Termination Status</a></h3><p>The <code>TerminationStatus</code> attribute indicates why the solver stopped executing. The value of the attribute is of type <code>TerminationStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.TerminationStatusCode" href="#MathOptInterface.TerminationStatusCode"><code>MathOptInterface.TerminationStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TerminationStatusCode</code></pre><p>An Enum of possible values for the <code>TerminationStatus</code> attribute. This attribute is meant to explain the reason why the solver stopped executing.</p><p><strong>OK</strong></p><p>These are generally OK statuses.</p><ul><li><p><code>Success</code>: the algorithm ran successfully and has a result; this includes cases where the algorithm converges to an infeasible point (NLP) or converges to a solution of a homogeneous self-dual problem and has a certificate of primal/dual infeasibility</p></li><li><p><code>InfeasibleNoResult</code>: the algorithm stopped because it decided that the problem is infeasible but does not have a result to return</p></li><li><p><code>UnboundedNoResult</code>: the algorithm stopped because it decided that the problem is unbounded but does not have a result to return</p></li><li><p><code>InfeasibleOrUnbounded</code>: the algorithm stopped because it decided that the problem is infeasible or unbounded (no result is available); this occasionally happens during MIP presolve</p></li></ul><p><strong>Limits</strong></p><p>The solver stopped because of some user-defined limit. To be documented: <code>IterationLimit</code>, <code>TimeLimit</code>, <code>NodeLimit</code>, <code>SolutionLimit</code>, <code>MemoryLimit</code>, <code>ObjectiveLimit</code>, <code>NormLimit</code>, <code>OtherLimit</code>.</p><p><strong>Problematic</strong></p><p>This group of statuses means that something unexpected or problematic happened.</p><ul><li><p><code>SlowProgress</code>: the algorithm stopped because it was unable to continue making progress towards the solution</p></li><li><p><code>AlmostSuccess</code> should be used if there is additional information that relaxed convergence tolerances are satisfied</p></li></ul><p>To be documented: <code>NumericalError</code>, <code>InvalidInstance</code>, <code>InvalidOption</code>, <code>Interrupted</code>, <code>OtherError</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L457-L486">source</a><br/></section><h3><a class="nav-anchor" id="Result-Status-1" href="#Result-Status-1">Result Status</a></h3><p>The <code>PrimalStatus</code> and <code>DualStatus</code> attributes indicate how to interpret the result returned by the solver. The value of the attribute is of type <code>ResultStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ResultStatusCode" href="#MathOptInterface.ResultStatusCode"><code>MathOptInterface.ResultStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ResultStatusCode</code></pre><p>An Enum of possible values for the <code>PrimalStatus</code> and <code>DualStatus</code> attributes. The values indicate how to interpret the result vector.</p><ul><li><p><code>FeasiblePoint</code></p></li><li><p><code>NearlyFeasiblePoint</code></p></li><li><p><code>InfeasiblePoint</code></p></li><li><p><code>InfeasibilityCertificate</code></p></li><li><p><code>NearlyInfeasibilityCertificate</code></p></li><li><p><code>ReductionCertificate</code></p></li><li><p><code>NearlyReductionCertificate</code></p></li><li><p><code>UnknownResultStatus</code></p></li><li><p><code>OtherResultStatus</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L491-L506">source</a><br/></section><h2><a class="nav-anchor" id="Variables-and-Constraints-1" href="#Variables-and-Constraints-1">Variables and Constraints</a></h2><h3><a class="nav-anchor" id="Basis-Status-1" href="#Basis-Status-1">Basis Status</a></h3><p>The <code>BasisStatus</code> attribute of a variable or constraint describes its status with respect to a basis, if one is known. The value of the attribute is of type <code>BasisStatusCode</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.BasisStatusCode" href="#MathOptInterface.BasisStatusCode"><code>MathOptInterface.BasisStatusCode</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BasisStatusCode</code></pre><p>An Enum of possible values for the <code>VariableBasisStatus</code> and <code>ConstraintBasisStatus</code> attribute. This explains the status of a given element with respect to an optimal solution basis. Possible values are:</p><ul><li><p><code>Basic</code>: element is in the basis</p></li><li><p><code>Nonbasic</code>: element is not in the basis</p></li><li><p><code>NonbasicAtLower</code>: element is not in the basis and is at its lower bound</p></li><li><p><code>NonbasicAtUpper</code>: element is not in the basis and is at its upper bound</p></li><li><p><code>SuperBasic</code>: element is not in the basis but is also not at one of its bounds</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L373-L384">source</a><br/></section><h3><a class="nav-anchor" id="References-1" href="#References-1">References</a></h3><pre><code class="language-none">VariableReference
ConstraintReference
candelete
isvalid
delete!(::AbstractSolverInstance,::AnyReference)
candelete</code></pre><h3><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h3><p>Functions for adding variables. For deleting, see references section.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariables!" href="#MathOptInterface.addvariables!"><code>MathOptInterface.addvariables!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariables!(m::AbstractSolverInstance, n::Int)::Vector{VariableReference}</code></pre><p>Add <code>n</code> scalar variables to the solver instance, returning a vector of variable references.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/variables.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addvariable!" href="#MathOptInterface.addvariable!"><code>MathOptInterface.addvariable!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addvariable!(m::AbstractSolverInstance)::VariableReference</code></pre><p>Add a scalar variable to the solver instance, returning a variable reference.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/variables.jl#L10-L14">source</a><br/></section><p>List of attributes associated with variables. [category AbstractVariableAttribute] Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>VariableReference</code> or a vector of <code>VariableReference</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimalStart" href="#MathOptInterface.VariablePrimalStart"><code>MathOptInterface.VariablePrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimalStart()</code></pre><p>An initial assignment of the variables that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L347-L351">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariablePrimal" href="#MathOptInterface.VariablePrimal"><code>MathOptInterface.VariablePrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariablePrimal(N)
VariablePrimal()</code></pre><p>The assignment to the primal variables in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L354-L360">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VariableBasisStatus" href="#MathOptInterface.VariableBasisStatus"><code>MathOptInterface.VariableBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VariableBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given variable, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L366-L370">source</a><br/></section><h3><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h3><p>Functions for adding and modifying constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.ConstraintReference}" href="#MathOptInterface.isvalid-Tuple{MathOptInterface.AbstractSolverInstance,MathOptInterface.ConstraintReference}"><code>MathOptInterface.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isvalid(m::AbstractSolverInstance, ref::AnyReference)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether this reference refers to a valid object in the solver instance <code>m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/references.jl#L31-L35">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addconstraint!" href="#MathOptInterface.addconstraint!"><code>MathOptInterface.addconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, func::F, set::S)::ConstraintReference{F,S} where {F,S}</code></pre><p>Add the constraint <span>$f(x) \in \mathcal{S}$</span> where <span>$f$</span> is defined by <code>func</code>, and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p><pre><code class="language-none">addconstraint!(m::AbstractSolverInstance, v::VariableReference, set::S)::ConstraintReference{SingleVariable,S} where {S}
addconstraint!(m::AbstractSolverInstance, vec::Vector{VariableReference}, set::S)::ConstraintReference{VectorOfVariables,S} where {S}</code></pre><p>Add the constraint <span>$v \in \mathcal{S}$</span> where <span>$v$</span> is the variable (or vector of variables) referenced by <code>v</code> and <span>$\mathcal{S}$</span> is defined by <code>set</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/constraints.jl#L3-L12">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.addconstraints!" href="#MathOptInterface.addconstraints!"><code>MathOptInterface.addconstraints!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraints!(m::AbstractSolverInstance, funcs::Vector{F}, sets::Vector{S})::Vector{ConstraintReference{F,S}} where {F,S}</code></pre><p>Add the set of constraints specified by each function-set pair in <code>funcs</code> and <code>sets</code>. <code>F</code> and <code>S</code> should be concrete types. This call is equivalent to <code>addconstraint!.(m, funcs, sets)</code> but may be more efficient.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/constraints.jl#L19-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.modifyconstraint!" href="#MathOptInterface.modifyconstraint!"><code>MathOptInterface.modifyconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Modify Function</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference{F,S}, func::F)</code></pre><p>Replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableReference</code> objects,</p><pre><code class="language-julia">modifyconstraint!(m, c, ScalarAffineFunction([v1,v2],[1.0,2.0],5.0))
modifyconstraint!(m, c, SingleVariable(v1)) # Error</code></pre><p><strong>Modify Set</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference{F,S}, set::S)</code></pre><p>Change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{F,Interval}</code></p><pre><code class="language-julia">modifyconstraint!(m, c, Interval(0, 5))
modifyconstraint!(m, c, NonPositives) # Error</code></pre><p><strong>Partial Modifications</strong></p><pre><code class="language-none">modifyconstraint!(m::AbstractSolverInstance, c::ConstraintReference, change::AbstractFunctionModification)</code></pre><p>Apply the modification specified by <code>change</code> to the function of constraint <code>c</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">modifyconstraint!(m, c, ScalarConstantChange(10.0))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/constraints.jl#L76-L118">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.canmodifyconstraint" href="#MathOptInterface.canmodifyconstraint"><code>MathOptInterface.canmodifyconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Modify Function</strong></p><pre><code class="language-none">canmodifyconstraint(m::AbstractSolverInstance, c::ConstraintReference{F,S}, func::F)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to replace the function in constraint <code>c</code> with <code>func</code>. <code>F</code> must match the original function type used to define the constraint.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{ScalarAffineFunction,S}</code> and <code>v1</code> and <code>v2</code> are <code>VariableReference</code> objects,</p><pre><code class="language-julia">canmodifyconstraint(m, c, ScalarAffineFunction([v1,v2],[1.0,2.0],5.0))
canmodifyconstraint(m, c, SingleVariable(v1)) # false</code></pre><p><strong>Modify Set</strong></p><pre><code class="language-none">canmodifyconstraint(m::AbstractSolverInstance, c::ConstraintReference{F,S}, set::S)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to change the set of constraint <code>c</code> to the new set <code>set</code> which should be of the same type as the original set.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{F,Interval}</code></p><pre><code class="language-julia">canmodifyconstraint(m, c, Interval(0, 5))
canmodifyconstraint(m, c, NonPositives) # false</code></pre><p><strong>Partial Modifications</strong></p><pre><code class="language-none">canmodifyconstraint(m::AbstractSolverInstance, c::ConstraintReference, change::AbstractFunctionModification)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether it is possible to apply the modification specified by <code>change</code> to the function of constraint <code>c</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">canmodifyconstraint(m, c, ScalarConstantChange(10.0))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/constraints.jl#L30-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.transformconstraint!" href="#MathOptInterface.transformconstraint!"><code>MathOptInterface.transformconstraint!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Transform Constraint Set</strong></p><pre><code class="language-none">transformconstraint!(m::AbstractSolverInstance, c::ConstraintReference{F,S1}, newset::S2)::ConstraintReference{F,S2}</code></pre><p>Replace the set in constraint <code>c</code> with <code>newset</code>. The constraint reference <code>c</code> will no longer be valid, and the function returns a new constraint reference.</p><p>Solvers may only support a subset of constraint transforms that they perform efficiently (for example, changing from a <code>LessThan</code> to <code>GreaterThan</code> set). In addition, set modification (where <code>S1 = S2</code>) should be performed via the <code>modifyconstraint!</code> function.</p><p>Typically, the user should delete the constraint and add a new one.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{ScalarAffineFunction{Float64},LessThan{Float64}}</code>,</p><pre><code class="language-julia">c2 = transformconstraint!(m, c, GreaterThan(0.0))
transformconstraint!(m, c, LessThan(0.0)) # errors</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/constraints.jl#L122-L146">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.cantransformconstraint" href="#MathOptInterface.cantransformconstraint"><code>MathOptInterface.cantransformconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Transform Constraint Set</strong></p><pre><code class="language-none">cantransformconstraint(m::AbstractSolverInstance, c::ConstraintReference{F,S1}, newset::S2)::Bool</code></pre><p>Return a <code>Bool</code> is the set in constraint <code>c</code> can be replaced with <code>newset</code>.</p><p><strong>Examples</strong></p><p>If <code>c</code> is a <code>ConstraintReference{ScalarAffineFunction{Float64},LessThan{Float64}}</code>,</p><pre><code class="language-julia">cantransformconstraint(m, c, GreaterThan(0.0)) # true
cantransformconstraint(m, c, ZeroOne())        # false</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/constraints.jl#L156-L171">source</a><br/></section><p>List of attributes associated with constraints. [category AbstractConstraintAttribute] Calls to <code>getattribute</code> and <code>setattribute!</code> should include as an argument a single <code>ConstraintReference</code> or a vector of <code>ConstraintReference{F,S}</code> objects.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimalStart" href="#MathOptInterface.ConstraintPrimalStart"><code>MathOptInterface.ConstraintPrimalStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimalStart()</code></pre><p>An initial assignment of the constraint primal values that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L389-L393">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDualStart" href="#MathOptInterface.ConstraintDualStart"><code>MathOptInterface.ConstraintDualStart</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDualStart()</code></pre><p>An initial assignment of the constraint duals that the solver may use to warm-start the solve.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L396-L400">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintPrimal" href="#MathOptInterface.ConstraintPrimal"><code>MathOptInterface.ConstraintPrimal</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintPrimal(N)
ConstraintPrimal()</code></pre><p>The assignment to the constraint primal values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L403-L409">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintDual" href="#MathOptInterface.ConstraintDual"><code>MathOptInterface.ConstraintDual</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintDual(N)
ConstraintDual()</code></pre><p>The assignment to the constraint dual values in result <code>N</code>. If <code>N</code> is omitted, it is 1 by default.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L415-L421">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintBasisStatus" href="#MathOptInterface.ConstraintBasisStatus"><code>MathOptInterface.ConstraintBasisStatus</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintBasisStatus()</code></pre><p>Returns the <code>BasisStatusCode</code> of a given constraint, with respect to an available optimal solution basis.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L427-L431">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintFunction" href="#MathOptInterface.ConstraintFunction"><code>MathOptInterface.ConstraintFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintFunction()</code></pre><p>Return the <code>AbstractFunction</code> object used to define the constraint. It is guaranteed to be equivalent but not necessarily identical to the function provided by the user.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L434-L439">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ConstraintSet" href="#MathOptInterface.ConstraintSet"><code>MathOptInterface.ConstraintSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConstraintSet()</code></pre><p>Return the <code>AbstractSet</code> object used to define the constraint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/attributes.jl#L442-L446">source</a><br/></section><h2><a class="nav-anchor" id="Functions-and-function-modifications-1" href="#Functions-and-function-modifications-1">Functions and function modifications</a></h2><p>List of recognized functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractFunction" href="#MathOptInterface.AbstractFunction"><code>MathOptInterface.AbstractFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractFunction</code></pre><p>Abstract supertype for function objects.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SingleVariable" href="#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SingleVariable(variable)</code></pre><p>The function that extracts the scalar variable referenced by <code>variable</code>, a <code>VariableReference</code>. This function is naturally be used for single variable bounds or integrality constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L25-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorOfVariables" href="#MathOptInterface.VectorOfVariables"><code>MathOptInterface.VectorOfVariables</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorOfVariables(variables)</code></pre><p>The function that extracts the vector of variables referenced by <code>variables</code>, a <code>Vector{VariableReference}</code>. This function is naturally be used for constraints that apply to groups of variables, such as an &quot;all different&quot; constraint, an indicator constraint, or a complementarity constraint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L35-L40">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarAffineFunction" href="#MathOptInterface.ScalarAffineFunction"><code>MathOptInterface.ScalarAffineFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarAffineFunction{T}(variables, coefficients, constant)</code></pre><p>The scalar-valued affine function <span>$a^T x + b$</span>, where:</p><ul><li><p><span>$a$</span> is a sparse vector specified in tuple form by <code>variables::Vector{VariableReference}</code> and <code>coefficients::Vector{T}</code></p></li><li><p><span>$b$</span> is a scalar specified by <code>constant::T</code></p></li></ul><p>Duplicate variable references in <code>variables</code> are accepted, and the corresponding coefficients are summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L45-L53">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorAffineFunction" href="#MathOptInterface.VectorAffineFunction"><code>MathOptInterface.VectorAffineFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorAffineFunction{T}(outputindex, variables, coefficients, constant)</code></pre><p>The vector-valued affine function <span>$A x + b$</span>, where:</p><ul><li><p><span>$A$</span> is a sparse matrix specified in triplet form by <code>outputindex, variables, coefficients</code></p></li><li><p><span>$b$</span> is a vector specified by <code>constant</code></p></li></ul><p>Duplicate indices in the <span>$A$</span> are accepted, and the corresponding coefficients are summed together.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L60-L68">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarQuadraticFunction" href="#MathOptInterface.ScalarQuadraticFunction"><code>MathOptInterface.ScalarQuadraticFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarQuadraticFunction{T}(affine_variables, affine_coefficients, quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients, constant)</code></pre><p>The scalar-valued quadratic function <span>$\frac{1}{2}x^TQx + a^T x + b$</span>, where:</p><ul><li><p><span>$a$</span> is a sparse vector specified in tuple form by <code>affine_variables, affine_coefficients</code></p></li><li><p><span>$b$</span> is a scalar specified by <code>constant</code></p></li><li><p><span>$Q$</span> is a symmetric matrix is specified in triplet form by <code>quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients</code></p></li></ul><p>Duplicate indices in <span>$a$</span> or <span>$Q$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableReferences</code>) are considered duplicates; only one need be specified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L76-L86">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorQuadraticFunction" href="#MathOptInterface.VectorQuadraticFunction"><code>MathOptInterface.VectorQuadraticFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorQuadraticFunction{T}(affine_variables, affine_coefficients, quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients, constant)</code></pre><p>The vector-valued quadratic function with i<code>th</code> component (&quot;output index&quot;) defined as <span>$\frac{1}{2}x^TQ_ix + a_i^T x + b_i$</span>, where:</p><ul><li><p><span>$a_i$</span> is a sparse vector specified in tuple form by the subset of <code>affine_variables, affine_coefficients</code> for the indices <code>k</code> where <code>affine_outputindex[k] == i</code>.</p></li><li><p><span>$b_i$</span> is a scalar specified by <code>constant[i]</code></p></li><li><p><span>$Q_i$</span> is a symmetric matrix is specified in triplet form by the subset of <code>quadratic_rowvariables, quadratic_colvariables, quadratic_coefficients</code> for the indices <code>k</code> where <code>quadratic_outputindex[k] == i</code></p></li></ul><p>Duplicate indices in <span>$a_i$</span> or <span>$Q_i$</span> are accepted, and the corresponding coefficients are summed together. &quot;Mirrored&quot; indices <code>(q,r)</code> and <code>(r,q)</code> (where <code>r</code> and <code>q</code> are <code>VariableReferences</code>) are considered duplicates; only one need be specified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L97-L107">source</a><br/></section><p>List of function modifications.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarConstantChange" href="#MathOptInterface.ScalarConstantChange"><code>MathOptInterface.ScalarConstantChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarConstantChange{T}(new_constant)</code></pre><p>A struct used to request a change in the constant term of a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L129-L134">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.VectorConstantChange" href="#MathOptInterface.VectorConstantChange"><code>MathOptInterface.VectorConstantChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VectorConstantChange{T}(new_constant)</code></pre><p>A struct used to request a change in the constant vector of a vector-valued function. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L139-L144">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ScalarCoefficientChange" href="#MathOptInterface.ScalarCoefficientChange"><code>MathOptInterface.ScalarCoefficientChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ScalarCoefficientChange{T}(variable, new_coefficient)</code></pre><p>A struct used to request a change in the linear coefficient of a single variable in a scalar-valued function. Applicable to <code>ScalarAffineFunction</code> and <code>ScalarQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L149-L155">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.MultirowChange" href="#MathOptInterface.MultirowChange"><code>MathOptInterface.MultirowChange</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">MultirowChange{T}(variable, rows, new_coefficients)</code></pre><p>A struct used to request a change in the linear coefficients of a single variable in a vector-valued function. Applicable to <code>VectorAffineFunction</code> and <code>VectorQuadraticFunction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/functions.jl#L161-L167">source</a><br/></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>List of recognized sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.AbstractSet" href="#MathOptInterface.AbstractSet"><code>MathOptInterface.AbstractSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSet</code></pre><p>Abstract supertype for set objects used to encode constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L3-L7">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Reals" href="#MathOptInterface.Reals"><code>MathOptInterface.Reals</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Reals(dim)</code></pre><p>The set <span>$\mathbb{R}^{dim}$</span> (containing all points) of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L32-L36">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Zeros" href="#MathOptInterface.Zeros"><code>MathOptInterface.Zeros</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zeros(dim)</code></pre><p>The set <span>$\{ 0 \}^{dim}$</span> (containing only the origin) of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L41-L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Nonnegatives" href="#MathOptInterface.Nonnegatives"><code>MathOptInterface.Nonnegatives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Nonnegatives(dim)</code></pre><p>The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dim} : x \ge 0 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L50-L54">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Nonpositives" href="#MathOptInterface.Nonpositives"><code>MathOptInterface.Nonpositives</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Nonpositives(dim)</code></pre><p>The nonpositive orthant <span>$\{ x \in \mathbb{R}^{dim} : x \le 0 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L59-L63">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.GreaterThan" href="#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GreaterThan(lower)</code></pre><p>The set <span>$[lower,\infty) \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L68-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.LessThan" href="#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LessThan(upper)</code></pre><p>The set <span>$(-\infty,upper] \subseteq \mathbb{R}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L77-L81">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.EqualTo" href="#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EqualTo(value)</code></pre><p>The set containing the single point <span>$x \in \mathbb{R}$</span> where <span>$x$</span> is given by <code>value</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L86-L90">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Interval" href="#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Interval(lower,upper)</code></pre><p>The interval <span>$[lower, upper] \subseteq \mathbb{R}$</span>. If <code>lower</code> or <code>upper</code> is <code>-Inf</code> or <code>Inf</code>, respectively, the set is interpreted as a one-sided interval.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L95-L100">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SecondOrderCone" href="#MathOptInterface.SecondOrderCone"><code>MathOptInterface.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SecondOrderCone(dim)</code></pre><p>The second-order cone (or Lorenz cone) <span>$\{ (t,x) \in \mathbb{R}^{dim} : t \ge || x ||_2 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L106-L110">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.RotatedSecondOrderCone" href="#MathOptInterface.RotatedSecondOrderCone"><code>MathOptInterface.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RotatedSecondOrderCone(dim)</code></pre><p>The rotated second-order cone <span>$\{ (t,u,x) \mathbb{R}^{dim} : 2tu \ge || x ||_2^2, t,u \ge 0 \}$</span> of dimension <code>dim</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L115-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ExponentialCone" href="#MathOptInterface.ExponentialCone"><code>MathOptInterface.ExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExponentialCone()</code></pre><p>The 3-dimensional exponential cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : y \exp (x/y) \le z, y &gt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L124-L128">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualExponentialCone" href="#MathOptInterface.DualExponentialCone"><code>MathOptInterface.DualExponentialCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualExponentialCone()</code></pre><p>The 3-dimensional dual exponential cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : -u \exp (v/u) \le \exp(1) w, u &lt; 0 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L132-L136">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PowerCone" href="#MathOptInterface.PowerCone"><code>MathOptInterface.PowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PowerCone(a)</code></pre><p>The 3-dimensional power cone <span>$\{ (x,y,z) \in \mathbb{R}^3 : x^{a} y^{1-a} &gt;= |z|, x \ge 0, y \ge 0 \}$</span> with parameter <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L140-L144">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.DualPowerCone" href="#MathOptInterface.DualPowerCone"><code>MathOptInterface.DualPowerCone</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DualPowerCone(a)</code></pre><p>The 3-dimensional power cone <span>$\{ (u,v,w) \in \mathbb{R}^3 : (\frac{u}{a})^a (\frac{v}/{1-a})^{1-a} &gt;= |w|, u \ge 0, v \ge 0 \}$</span> with parameter <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L149-L153">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeTriangle" href="#MathOptInterface.PositiveSemidefiniteConeTriangle"><code>MathOptInterface.PositiveSemidefiniteConeTriangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeTriangle(dim)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals unscaled. The entries of the upper triangular part of the matrix are given row by row (or equivalently, the entries of the lower triangular part are given column by column). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <code>dim</code>, the corresponding symmetric matrix has side dimension <span>$\sqrt (1/4 + 2 dim) - 1/2$</span> elements. The scalar product is the sum of the pairwise product of the diagonal entries plus twice the sum of the pairwise product of the upper diagonal entries.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 3\\
  2 &amp; 4 &amp; 5\\
  3 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>corresponds to <span>$(1, 2, 3, 4, 5, 6)$</span> for <code>PositiveSemidefiniteConeTriangle</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L160-L179">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.PositiveSemidefiniteConeScaled" href="#MathOptInterface.PositiveSemidefiniteConeScaled"><code>MathOptInterface.PositiveSemidefiniteConeScaled</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PositiveSemidefiniteConeScaled(dim)</code></pre><p>The (vectorized) cone of symmetric positive semidefinite matrices, with off-diagonals scaled. The entries of the upper triangular part of the matrix are given row by row (or equivalently, the entries of the lower triangular part are given column by column). An <span>$n \times n$</span> matrix has <span>$n(n+1)/2$</span> lower-triangular elements, so for the vectorized cone of dimension <code>dim</code>, the corresponding symmetric matrix has side dimension <span>$\sqrt (1/4 + 2 dim) - 1/2$</span> elements. The off-diagonal entries of the matrices of both the cone and its dual are scaled by <span>$\sqrt{2}$</span> and the scalar product is simply the sum of the pairwise product of the entries.</p><p><strong>Examples</strong></p><p>The matrix</p><div>\[\begin{bmatrix}
  1 &amp; 2 &amp; 3\\
  2 &amp; 4 &amp; 5\\
  3 &amp; 5 &amp; 6
\end{bmatrix}\]</div><p>and to <span>$(1, 2\sqrt{2}, 3\sqrt{2}, 4, 5\sqrt{2}, 6)$</span> for <code>PositiveSemidefiniteConeScaled</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L184-L203">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Integer" href="#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Integer()</code></pre><p>The set of integers <span>$\mathbb{Z}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L208-L212">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.ZeroOne" href="#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ZeroOne()</code></pre><p>The set <span>$\{ 0, 1 \}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L215-L219">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Semicontinuous" href="#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Semicontinuous(l,u)</code></pre><p>The set <span>$\{0\} \cup [l,u]$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L222-L226">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.Semiinteger" href="#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Semiinteger(l,u)</code></pre><p>The set <span>$\{0\} \cup \{l,l+1,\ldots,u-1,u\}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L232-L236">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS1" href="#MathOptInterface.SOS1"><code>MathOptInterface.SOS1</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS1(weights)</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 1. Of the variables in the set, at most one can be nonzero. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L242-L250">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.SOS2" href="#MathOptInterface.SOS2"><code>MathOptInterface.SOS2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SOS2(weights)</code></pre><p>The set corresponding to the special ordered set (SOS) constraint of type 2. Of the variables in the set, at most two can be nonzero, and if two are nonzero, they must be adjacent in the ordering of the set. The <code>weights</code> induce an ordering of the variables; as such, they should be unique values. The <em>k</em>th element in the set corresponds to the <em>k</em>th weight in <code>weights</code>. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for a description of SOS constraints and their potential uses.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L255-L263">source</a><br/></section><p>Functions for getting and setting properties of sets.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathOptInterface.dimension" href="#MathOptInterface.dimension"><code>MathOptInterface.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dimension(s::AbstractVectorSet)</code></pre><p>Return the underlying dimension (number of vector components) in the set <code>s</code>, i.e., <span>$n$</span> if the set is a subset of <span>$\mathbb{R}^n$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/37539211a3968cde00f06aadf8bed43ec6c717fd/src/sets.jl#L24-L29">source</a><br/></section><h2><a class="nav-anchor" id="Objectives-1" href="#Objectives-1">Objectives</a></h2><p>Functions for adding and modifying objectives.</p><pre><code class="language-none">setobjective!
modifyobjective!
canmodifyobjective</code></pre><footer><hr/><a class="previous" href="apimanual.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
