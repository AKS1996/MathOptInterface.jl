<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="apimanual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Purpose-1">Purpose</a></li><li><a class="toctext" href="#Standard-form-problem-1">Standard form problem</a></li><li><a class="toctext" href="#Solvers-and-solver-instances-1">Solvers and solver instances</a></li><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Solving-and-retrieving-the-results-1">Solving and retrieving the results</a></li><li><a class="toctext" href="#A-complete-example:-solveknapsack-1">A complete example: <code>solveknapsack</code></a></li><li><a class="toctext" href="#A-more-complex-example:-solveintegerlinear-1">A more complex example: <code>solveintegerlinear</code></a></li><li><a class="toctext" href="#Advanced-1">Advanced</a></li></ul></li><li><a class="toctext" href="apireference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apimanual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/bcc1862b832e4c08f764cb1c56c0fed8b0e456ae/docs/src/apimanual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h2><a class="nav-anchor" id="Purpose-1" href="#Purpose-1">Purpose</a></h2><p>Each mathematical optimization solver API has its own concepts and data structures for representing optimization instances and obtaining results. However, it is often desirable to represent an instance of an optimization problem at a higher level so that it is easy to try using different solvers. MathOptInterface (MOI) is an abstraction layer designed to provide a unified interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a>.</p><p>MOI has been designed to replace <a href="https://github.com/JuliaOpt/MathProgBase.jl">MathProgBase</a>, which has been used by modeling packages such as <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a> and <a href="https://github.com/JuliaOpt/Convex.jl">Convex.jl</a>. This second-generation abstraction layer addresses a number of limitations of MathProgBase. MOI is designed to:</p><ul><li><p>Be simple and extensible, unifying linear, quadratic, and conic optimization, and seamlessly facilitate extensions to essentially arbitrary constraints and functions (e.g., indicator constraints, complementarity constraints, and piecewise linear functions)</p></li><li><p>Be fast by allowing access to a solver&#39;s in-memory representation of a problem without writing intermediate files (when possible) and by using multiple dispatch and avoiding requiring containers of nonconcrete types</p></li><li><p>Allow a solver to return multiple results (e.g., a pool of solutions)</p></li><li><p>Allow a solver to return extra arbitrary information via attributes (e.g., variable- and constraint-wise membership in an irreducible inconsistent subset for infeasibility analysis)</p></li><li><p>Provide a greatly expanded set of status codes explaining what happened during the optimization procedure</p></li><li><p>Enable a solver to more precisely specify which problem classes it supports</p></li><li><p>Enable both primal and dual warm starts</p></li><li><p>Enable adding and removing both variables and constraints by using reference objects instead of integer indices</p></li><li><p>Enable any modification that the solver supports to an existing instance</p></li><li><p>Avoid requiring the solver wrapper to store an additional copy of the problem data</p></li></ul><p>This manual introduces the concepts needed to understand MOI and give a high-level picture of how all of the pieces fit together. The primary focus is on MOI from the perspective of a user of the interface. At the end of the manual we have a section on <a href="apimanual.html#Implementing-a-solver-interface-1">Implementing a solver interface</a>. The <a href="apireference.html#API-Reference-1">API Reference</a> page lists the complete API.</p><h2><a class="nav-anchor" id="Standard-form-problem-1" href="#Standard-form-problem-1">Standard form problem</a></h2><p>The standard form problem is:</p><div>\[\begin{align}
    &amp; \min_{x \in \mathbb{R}^n} &amp; f_0(x)
    \\
    &amp; \;\;\text{s.t.} &amp; f_i(x) &amp; \in \mathcal{S}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>where:</p><ul><li><p>the functions <span>$f_0, f_1, \ldots, f_m$</span> are specified by <a href="apireference.html#MathOptInterface.AbstractFunction"><code>AbstractFunction</code></a> objects</p></li><li><p>the sets <span>$\mathcal{S}_1, \ldots, \mathcal{S}_m$</span> are specified by <a href="apireference.html#MathOptInterface.AbstractSet"><code>AbstractSet</code></a> objects</p></li></ul><p>The current function types are:</p><ul><li><p><strong>projection onto a single coordinate</strong>: <span>$x_j$</span>, a single variable defined by a variable reference</p></li><li><p><strong>projection onto multiple coordinates</strong>: a subvector of variables defined by a list of variable references</p></li><li><p><strong>scalar-valued affine</strong>: <span>$a^T x + b$</span>, where <span>$a$</span> is a vector and <span>$b$</span> scalar</p></li><li><p><strong>vector-valued affine</strong>: <span>$A x + b$</span>, where <span>$A$</span> is a matrix and <span>$b$</span> is a vector</p></li><li><p><strong>scalar-valued quadratic</strong>: <span>$\frac{1}{2} x^T Q x + a^T x + b$</span>, where <span>$Q$</span> is a symmetric matrix, <span>$a$</span> is a vector, and <span>$b$</span> is a constant</p></li><li><p><strong>vector-valued quadratic</strong>: a vector of scalar-valued quadratic expressions</p></li></ul><p>In a future version, MOI could be extended to cover functions defined by evaluation oracles (e.g., for nonlinear derivative-based optimization).</p><p>MOI defines some commonly used sets, but the interface is extensible to other sets recognized by the solver. [Describe currently supported sets.]</p><h2><a class="nav-anchor" id="Solvers-and-solver-instances-1" href="#Solvers-and-solver-instances-1">Solvers and solver instances</a></h2><p>Solvers are &quot;factories&quot; used to specify solver-specific parameters and create new instances of a solver API. Solver instances should be understood as the representation of the problem <em>in the solver&#39;s API</em>, just as if one were using its API directly. When possible, the MOI wrapper for a solver should avoid storing an extra copy of the problem data.</p><p>Through the rest of the manual, <code>m</code> is used as a generic solver instance.</p><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><p>MOI has a concept of a scalar variable (only). New scalar variables are created with <a href="apireference.html#MathOptInterface.addvariable!"><code>addvariable!</code></a> or <a href="apireference.html#MathOptInterface.addvariables!"><code>addvariables!</code></a>, which return a <a href="apireference.html#MathOptInterface.VariableReference"><code>VariableReference</code></a> or <code>Vector{VariableReference}</code> respectively. Integer indices are never used to reference variables.</p><p>One uses <code>VariableReference</code> objects to set and get variable attributes. For example, the <a href="apireference.html#MathOptInterface.VariablePrimalStart"><code>VariablePrimalStart</code></a> attribute is used to provide an initial starting point for a variable or collection of variables:</p><pre><code class="language-julia">v = addvariable!(m)
setattribute!(m, VariablePrimalStart(), v, 10.5)
v2 = addvariables!(m, 3)
setattribute!(m, VariablePrimalStart(), v2, [1.3,6.8,-4.6])</code></pre><p>A variable can be deleted from a model with <a href="apireference.html#Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.ConstraintReference, MathOptInterface.VariableReference}}"><code>delete!(::AbstractSolverInstance, ::VariableReference)</code></a>, if this functionality is supported by the solver.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><p>MOI defines six functions as listed in the definition of the <a href="apimanual.html#Standard-form-problem-1">Standard form problem</a>. The simplest function is <a href="apireference.html#MathOptInterface.SingleVariable"><code>SingleVariable</code></a> defined as:</p><pre><code class="language-julia">struct SingleVariable &lt;: AbstractFunction
    variable::VariableReference
end</code></pre><p>If <code>v</code> is a <code>VariableReference</code> object, then <code>SingleVariable(v)</code> is simply the scalar-valued function from the complete set of variables in an instance that returns the value of variable <code>v</code>. One may also call this function a coordinate projection, which is more useful for defining constraints than as an objective function.</p><p>A more interesting function is <a href="apireference.html#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>, defined as</p><pre><code class="language-julia">struct ScalarAffineFunction{T} &lt;: AbstractFunction
    variables::Vector{VariableReference}
    coefficients::Vector{T}
    constant::T
end</code></pre><p>If <code>x</code> is a vector of <code>VariableReference</code> objects, then <code>ScalarAffineFunction([x[1],x[2]],[5.0,-2.3],1.0)</code> represents the function <span>$5x_1 - 2.3x_2 + 1$</span>.</p><p>Objective functions are assigned to an instance by calling <a href="apireference.html#MathOptInterface.setobjective!"><code>setobjective!</code></a>. For example,</p><pre><code class="language-julia">x = addvariables!(m, 2)
setobjective!(m, MinSense, ScalarAffineFunction([x[1],x[2]],[5.0,-2.3],1.0))</code></pre><p>sets the objective to the function just discussed in the minimization sense.</p><p>See <a href="apireference.html#Functions-and-function-modifications-1">Functions and function modifications</a> for the complete list of functions.</p><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>All constraints are specified with <a href="apireference.html#MathOptInterface.addconstraint!"><code>addconstraint!</code></a> by restricting the output of some function to a set. The interface allows an arbitrary combination of functions and sets, but of course solvers may decide to support only a small number of combinations (see <a href="apireference.html#MathOptInterface.supportsproblem"><code>supportsproblem</code></a>).</p><p>For example, linear programming solvers should support, at least, combinations of affine functions with the <a href="apireference.html#MathOptInterface.LessThan"><code>LessThan</code></a> and <a href="apireference.html#MathOptInterface.GreaterThan"><code>GreaterThan</code></a> sets. These are simply linear constraints. <code>SingleVariable</code> functions combined with these same sets are used to specify upper and lower bounds on variables.</p><p>The code example below encodes the linear optimization problem:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^2} &amp; 3x_1 + 2x_2 &amp;
\\
&amp; \;\;\text{s.t.} &amp; x_1 + x_2 &amp;\le 5
\\
&amp;&amp; x_1 &amp; \ge 0
\\
&amp;&amp;x_2 &amp; \ge -1
\end{align}\]</div><pre><code class="language-julia">x = addvariables!(m, 2)
setobjective!(m, MaxSense, ScalarAffineFunction(x, [3.0,2.0], 0.0))
addconstraint!(m, ScalarAffineFunction(x, [1.0,1.0], 0.0), LessThan(5.0))
addconstraint!(m, SingleVariable(x[1]), GreaterThan(0.0))
addconstraint!(m, SingleVariable(x[2]), GreaterThan(-1.0))</code></pre><p>[Example with vector-valued set.]</p><h3><a class="nav-anchor" id="Constraints-by-function-set-pairs-1" href="#Constraints-by-function-set-pairs-1">Constraints by function-set pairs</a></h3><p>Below is a list of common constraint types and how they are represented as function-set pairs in MOI. In the notation below, <span>$x$</span> is a vector of decision variables, <span>$x_i$</span> is a scalar decision variable, and all other terms are fixed constants.</p><p>[Define notation more precisely. <span>$a$</span> vector; <span>$A$</span> matrix; don&#39;t reuse <span>$u,l,b$</span> as scalar and vector]</p><h4><a class="nav-anchor" id="Linear-constraints-1" href="#Linear-constraints-1">Linear constraints</a></h4><table><tr><th>Mathematical Constraint</th><th>MOI Function</th><th>MOI Set</th></tr><tr><td><span>$a^Tx \le u$</span></td><td><code>ScalarAffineFunction</code></td><td><code>LessThan</code></td></tr><tr><td><span>$a^Tx \ge l$</span></td><td><code>ScalarAffineFunction</code></td><td><code>GreaterThan</code></td></tr><tr><td><span>$a^Tx = b$</span></td><td><code>ScalarAffineFunction</code></td><td><code>EqualTo</code></td></tr><tr><td><span>$l \le a^Tx \le u$</span></td><td><code>ScalarAffineFunction</code></td><td><code>Interval</code></td></tr><tr><td><span>$x_i \le u$</span></td><td><code>SingleVariable</code></td><td><code>LessThan</code></td></tr><tr><td><span>$x_i \ge l$</span></td><td><code>SingleVariable</code></td><td><code>GreaterThan</code></td></tr><tr><td><span>$x_i = b$</span></td><td><code>SingleVariable</code></td><td><code>EqualTo</code></td></tr><tr><td><span>$l \le x_i \le u$</span></td><td><code>SingleVariable</code></td><td><code>Interval</code></td></tr><tr><td><span>$Ax + b \in \mathbb{R}_+^n$</span></td><td><code>VectorAffineFunction</code></td><td><code>Nonnegatives</code></td></tr><tr><td><span>$Ax + b \in \mathbb{R}_-^n$</span></td><td><code>VectorAffineFunction</code></td><td><code>Nonpositives</code></td></tr><tr><td><span>$Ax + b = 0$</span></td><td><code>VectorAffineFunction</code></td><td><code>Zeros</code></td></tr></table><p>By convention, solvers are not expected to support nonzero constant terms in the <code>ScalarAffineFunction</code>s the first four rows above, because they are redundant with the parameters of the sets. For example, <span>$2x + 1 \le 2$</span> should be encoded as <span>$2x \le 1$</span>.</p><p>Constraints with <code>SingleVariable</code> in <code>LessThan</code>, <code>GreaterThan</code>, <code>EqualTo</code>, or <code>Interval</code> sets have a natural interpretation as variable bounds. As such, it is typically not natural to impose multiple lower or upper bounds on the same variable, and by convention we do not ask solver interfaces to support this. It is natural, however, to impose upper and lower bounds separately as two different constraints on a single variable. The difference between imposing bounds by using a single <code>Interval</code> constraint and by using separate <code>LessThan</code> and <code>GreaterThan</code> constraints is that the latter will allow the solver to return separate dual multipliers for the two bounds, while the former will allow the solver to return only a single dual for the interval constraint.</p><p>[Define <span>$\mathbb{R}_+, \mathbb{R}_-$</span>]</p><h4><a class="nav-anchor" id="Conic-constraints-1" href="#Conic-constraints-1">Conic constraints</a></h4><table><tr><th>Mathematical Constraint</th><th>MOI Function</th><th>MOI Set</th></tr><tr><td><span>$\lVert Ax + b\rVert_2 \le c^Tx + d$</span></td><td><code>VectorAffineFunction</code></td><td><code>SecondOrderCone</code></td></tr><tr><td><span>$y \ge \lVert x \rVert_2$</span></td><td><code>VectorOfVariables</code></td><td><code>SecondOrderCone</code></td></tr><tr><td><span>$2yz \ge \lVert x \rVert_2^2, y,z \ge 0$</span></td><td><code>VectorOfVariables</code></td><td><code>RotatedSecondOrderCone</code></td></tr><tr><td><span>$(a_1^Tx + b_1,a_2^Tx + b_2,a_3^Tx + b_3) \in \mathcal{E}$</span></td><td><code>VectorAffineFunction</code></td><td><code>ExponentialCone</code></td></tr><tr><td><span>$A(x) \in \mathcal{S}_+$</span></td><td><code>VectorAffineFunction</code></td><td><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td><span>$A(x) \in \mathcal{S}&#39;_+$</span></td><td><code>VectorAffineFunction</code></td><td><code>PositiveSemidefiniteConeScaled</code></td></tr><tr><td><span>$x \in \mathcal{S}_+$</span></td><td><code>VectorOfVariables</code></td><td><code>PositiveSemidefiniteConeTriangle</code></td></tr><tr><td><span>$x \in \mathcal{S}&#39;_+$</span></td><td><code>VectorOfVariables</code></td><td><code>PositiveSemidefiniteConeScaled</code></td></tr></table><p>[Define <span>$\mathcal{E}$</span> (exponential cone), <span>$\mathcal{S}_+$</span> (smat), <span>$\mathcal{S}&#39;_+$</span> (svec). <span>$A(x)$</span> is an affine function of <span>$x$</span> that outputs a matrix.]</p><h4><a class="nav-anchor" id="Quadratic-constraints-1" href="#Quadratic-constraints-1">Quadratic constraints</a></h4><table><tr><th>Mathematical Constraint</th><th>MOI Function</th><th>MOI Set</th></tr><tr><td><span>$x^TQx + a^Tx + b \ge 0$</span></td><td><code>ScalarQuadraticFunction</code></td><td><code>GreaterThan</code></td></tr><tr><td><span>$x^TQx + a^Tx + b \le 0$</span></td><td><code>ScalarQuadraticFunction</code></td><td><code>LessThan</code></td></tr><tr><td><span>$x^TQx + a^Tx + b = 0$</span></td><td><code>ScalarQuadraticFunction</code></td><td><code>EqualTo</code></td></tr><tr><td>Bilinear matrix inequality</td><td><code>VectorQuadraticFunction</code></td><td><code>PositiveSemidefiniteCone...</code></td></tr></table><h4><a class="nav-anchor" id="Discrete-and-logical-constraints-1" href="#Discrete-and-logical-constraints-1">Discrete and logical constraints</a></h4><table><tr><th>Mathematical Constraint</th><th>MOI Function</th><th>MOI Set</th></tr><tr><td><span>$x_i \in \mathbb{Z}$</span></td><td><code>SingleVariable</code></td><td><code>Integer</code></td></tr><tr><td><span>$x_i \in \{0,1\}$</span></td><td><code>SingleVariable</code></td><td><code>ZeroOne</code></td></tr><tr><td><span>$x_i \in \{0\} \cup [l,u]$</span></td><td><code>SingleVariable</code></td><td><code>Semicontinuous</code></td></tr><tr><td><span>$x_i \in \{0\} \cup \{l,l+1,\ldots,u-1,u\}$</span></td><td><code>SingleVariable</code></td><td><code>SemiInteger</code></td></tr><tr><td>At most one component of <span>$x$</span> can be nonzero</td><td><code>VectorOfVariables</code></td><td><code>SOS1</code></td></tr><tr><td>At most two components of <span>$x$</span> can be nonzero, and if so they must be adjacent components</td><td><code>VectorOfVariables</code></td><td><code>SOS2</code></td></tr></table><h2><a class="nav-anchor" id="Solving-and-retrieving-the-results-1" href="#Solving-and-retrieving-the-results-1">Solving and retrieving the results</a></h2><p>Once a solver instance is loaded with the objective function and all of the constraints, we can ask the solver to solve the instance by calling <a href="apireference.html#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><pre><code class="language-julia">optimize!(m)</code></pre><p>The optimization procedure may terminate for a number of reasons. The <a href="apireference.html#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> attribute of the solver instance returns a <a href="apireference.html#MathOptInterface.TerminationStatusCode"><code>TerminationStatusCode</code></a> object which explains why the solver stopped. Some statuses indicate generally successful termination, some termination because of limit, and some termination because of something unexpected like invalid problem data or failure to converge. A typical usage of the <code>TerminationStatus</code> attribute is as follows:</p><pre><code class="language-julia">status = getattribute(m, TerminationStatus())
if status == Success
    # Ok, the solver has a result to return
else
    # Handle other cases
    # The solver may or may not have a result
end</code></pre><p>The <code>Success</code> status code specifically implies that the solver has a &quot;result&quot; to return. In the case that the solver converged to an optimal solution, this result will just be the optimal solution vector. The <a href="apireference.html#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> attribute returns a <a href="apireference.html#MathOptInterface.ResultStatusCode"><code>ResultStatusCode</code></a> that explains how to interpret the result. In the case that the solver is known to return globally optimal solutions (up to numerical tolerances), the combination of <code>Success</code> termination status and <code>FeasiblePoint</code> primal result status implies that the primal result vector should be interpreted as a globally optimal solution. A result may be available even if the status is not <code>Success</code>, for example, if the solver stopped because of a time limit and has a feasible but nonoptimal solution. Use the <a href="apireference.html#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute to check if one or more results are available.</p><p>In addition to the primal status, the <a href="apireference.html#MathOptInterface.DualStatus"><code>DualStatus</code></a> provides important information for primal-dual solvers.</p><p>If a result is available, it may be retrieved with the <a href="apireference.html#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a> attribute:</p><pre><code class="language-julia">getattribute(m, VariablePrimal(), x)</code></pre><p>If <code>x</code> is a <code>VariableRefrence</code> then the function call returns a scalar, and if <code>x</code> is a <code>Vector{VariableReference}</code> then the call returns a vector of scalars. <code>VariablePrimal()</code> is equivalent to <code>VariablePrimal(1)</code>, i.e., the variable primal vector of the first result. Use <code>VariablePrimal(N)</code> to access the <code>N</code>th result.</p><p>See also the attributes <a href="apireference.html#MathOptInterface.ConstraintPrimal"><code>ConstraintPrimal</code></a>, and <a href="apireference.html#MathOptInterface.ConstraintDual"><code>ConstraintDual</code></a>. See <a href="apimanual.html#Duals-1">Duals</a> for a discussion of the MOI conventions for primal-dual pairs and certificates.</p><h3><a class="nav-anchor" id="Common-status-situations-1" href="#Common-status-situations-1">Common status situations</a></h3><p>The sections below describe how to interpret different status cases for three common classes of solvers. Most importantly, it is essential to know if a solver is expected to provide a global or only locally optimal solution when interpreting the result statuses. Solver wrappers may provide additional information on how the solver&#39;s statuses map to MOI statuses.</p><h4><a class="nav-anchor" id="Primal-dual-convex-solver-1" href="#Primal-dual-convex-solver-1">Primal-dual convex solver</a></h4><p>A typical primal-dual solver is capable of certifying optimality of a solution to a convex optimization problem by providing a primal-dual feasible solution with matching objective values. It may also certify that either the primal or dual problem is infeasible by providing a certain ray of the dual or primal, respectively. Typically two solves are required to certify unboundedness, one to find a ray and a second to find a feasible point. A solver may also provide a <a href="http://www.optimization-online.org/DB_FILE/2015/09/5104.pdf">facial reduction certificate</a>. When a primal-dual solver terminates with <code>Success</code> status, it is reasonable to assume that a primal and dual statuses of <code>FeasiblePoint</code> imply that the corresponding primal-dual results are a (numerically) optimal primal-dual pair. The <code>AlmostSuccess</code> status implies that the solve has completed to relaxed tolerances, so in this case <code>FeasiblePoint</code> or <code>NearlyFeasiblePoint</code> statuses would imply a near-optimal primal-dual pair. For all other termination statuses, there are no specific guarantees on the results returned.</p><h4><a class="nav-anchor" id="Global-mixed-integer-or-nonconvex-solver-1" href="#Global-mixed-integer-or-nonconvex-solver-1">Global mixed-integer or nonconvex solver</a></h4><p>When a global solver returns <code>Success</code> and the primal result is a <code>FeasiblePoint</code>, then it is implied that the primal result is indeed a globally optimal solution up to the specified tolerances. Typically, no dual certificate is available to certify optimality. The <a href="apireference.html#MathOptInterface.ObjectiveBound"><code>ObjectiveBound</code></a> should provide extra information on the optimality gap.</p><h4><a class="nav-anchor" id="Local-solver-1" href="#Local-solver-1">Local solver</a></h4><p>For solvers which perform a search based only on local criteria (for example, gradient descent), without additional knowledge of the structure of the problem, we can say only that <code>Success</code> and <code>FeasiblePoint</code> imply that the primal result belongs to the class of points which the chosen algorithm is known to converge to. Gradient descent algorithms may converge to saddle points, for example. It is also possible for such algorithms to converge to infeasible points, in which case the termination status would be <code>Success</code> and the primal result status would be <code>InfeasiblePoint</code>. This does not imply that the problem is infeasible and so cannot be called a certificate of infeasibility.</p><h2><a class="nav-anchor" id="A-complete-example:-solveknapsack-1" href="#A-complete-example:-solveknapsack-1">A complete example: <code>solveknapsack</code></a></h2><p>The <code>solveknapsack</code> function below demonstrates the complete process from data to solver instance to result vector using MOI.</p><p>[ needs formatting help ]</p><pre><code class="language-julia">&quot;&quot;&quot;
    solveknapsack(c, w, C)

Solve the binary-constrained knapsack problem: max c&#39;x: w&#39;x &lt;= C, x binary.
Returns the optimal weights and objective value. Throws an error if the solver
does not terminate with a `Success` status.
&quot;&quot;&quot;
function solveknapsack(c::Vector{Float64}, w::Vector{Float64}, C::Float64, solver::AbstractSolver)
    if !supportsproblem(solver, ScalarAffineFunction,
            [(ScalarAffineFunction,LessThan),
             (SingleVariable,ZeroOne)])
        error(&quot;Provided solver cannot solve binary knapsack problems&quot;)
    end
    numvar = length(c)
    @assert numvar == length(w)

    m = SolverInstance(solver)

    # create the variables in the problem
    x = addvariables!(m, numvar)

    # set the objective function
    setobjective!(m, MaxSense, ScalarAffineFunction(x, c, 0.0))

    # add the knapsack constraint
    addconstraint!(m, ScalarAffineFunction(x, w, 0.0), LessThan(C))

    # add integrality constraints
    for i in 1:numvar
        addconstraint!(m, SingleVariable(x[i]), ZeroOne())
    end

    # all set
    optimize!(m)

    termination_status = getattribute(m, TerminationStatus())
    objvalue = cangetattribute(m, ObjectiveValue()) ? getattribute(m, ObjectiveValue()) : NaN
    if termination_status != Success
        error(&quot;Solver terminated with status $termination_status&quot;)
    end

    @assert getattribute(m, ResultCount()) &gt; 0

    result_status = getattribute(m, PrimalStatus())
    if result_status != FeasiblePoint
        error(&quot;Solver ran successfully did not return a feasible point. The problem may be infeasible.&quot;)
    end
    primal_variable_result = getattribute(m, VariableResult(), x)

    return (objvalue, primal_variable_result)
end</code></pre><h2><a class="nav-anchor" id="A-more-complex-example:-solveintegerlinear-1" href="#A-more-complex-example:-solveintegerlinear-1">A more complex example: <code>solveintegerlinear</code></a></h2><p>[this needs formatting help]</p><pre><code class="language-julia">&quot;&quot;&quot;
    IntegerLinearResult

A `struct` returned by `solverintegerlinear` containing solution information.
The fields are as follows:

  - `termination_status`: the `TerminationStatusCode` returned by the solver
  - `result_status`: the `ResultStatusCode` returned by the solver (if any results are available)
  - `primal_variable_result`: the primal result vector returned by the solver; if no result is returned then this vector has length zero
  - `objective_value`: the objective value of the result vector as reported by the solver
  - `objective_bound`: the best known bound on the optimal objective value
&quot;&quot;&quot;
struct IntegerLinearResult
    termination_status::TerminationStatusCode
    result_status::ResultStatusCode
    primal_variable_result::Vector{Float64}
    objective_value::Float64
    objective_bound::Float64
end

&quot;&quot;&quot;
    solveintegerlinear(c, Ale, ble, Aeq, beq, lb, ub, integerindices, solver)

Solve the mixed-integer linear optimization problem: min c&#39;x s.t. `Ale*x` &lt;= `ble`, `Aeq*x` = `beq`, `lb` &lt;= `x` &lt;= `ub`, and`x[i]` is integer for `i` in `integerindices` using the solver specified by `solver`. Returns an `IntegerLinearResult`.
&quot;&quot;&quot;
function solverintegerlinear(c, Ale::SparseMatrixCSC, ble, Aeq::SparseMatrixCSC, beq, lb, ub, integerindices, solver)
    if !supportsproblem(solver, ScalarAffineFunction{Float64},
            [(ScalarAffineFunction,LessThan{Float64}),
             (ScalarAffineFunction,Zeros),
             (SingleVariable,LessThan{Float64}),
             (SingleVariable,GreaterThan{Float64}),
             (SingleVariable,Integer)])
        error(&quot;Provided solver does not support mixed-integer linear optimization&quot;)
    end
    numvar = size(Ale,2)
    @assert numvar == size(Aeq,2) == length(lb) == length(ub)


    m = SolverInstance(solver)

    # create the variables in the problem
    x = addvariables!(m, numvar)

    # set the objective function
    setobjective!(m, MinSense, ScalarAffineFunction(x, c, 0.0))

    # add variable bound constraints
    for i in 1:numvar
        if isfinite(lb[i])
            addconstraint!(m, SingleVariable(x[i]), GreaterThan(lb[i]))
        end
        if isfinite(ub[i])
            addconstraint!(m, SingleVariable(x[i]), LessThan(ub[i]))
        end
    end

    # add integrality constraints
    for i in integerindices
        @assert 1 &lt;= i &lt;= numvar
        addconstraint!(m, SingleVariable(x[i]), Integer())
    end

    # convert a SparseMatrixCSC into a vector of scalar affine functions
    # meant to be illustrative, not the fastest possible
    function csc_to_affine(A::SparseMatrixCSC)
        nrow = size(A,1)
        variables_by_row = [Vector{VariableReference}(0) for k in 1:nrow]
        coefficients_by_row = [Vector{Float64}(0) for k in 1:nrow]

        I,J,V = findnz(A) # convert the sparse matrix to triplet form
        for p in 1:length(I)
            push!(variables_by_row[I[p]], x[J[p]])
            push!(coefficients_by_row[I[p]], V[p])
        end
        return [ScalarAffineFunction(variables_by_row[k], coefficients_by_row[k], 0.0) for k in 1:nrow]
    end

    # add inequality constraints
    Ale_affine = csc_to_affine(Ale)
    for k in 1:length(Ale_affine)
        addconstraint!(m, Ale_affine[k], LessThan(ble[k]))
    end

    # add equality constraints
    Aeq_affine = csc_to_affine(Aeq)
    for k in 1:length(Aeq_affine)
        addconstraint!(m, Aeq_affine[k], EqualTo(beq[k]))
    end

    # all set
    optimize!(m)

    termination_status = getattribute(m, TerminationStatus())
    objbound = cangetattribute(m, ObjectiveBound()) ? getattribute(m, ObjectiveBound()) : NaN
    objvalue = cangetattribute(m, ObjectiveValue()) ? getattribute(m, ObjectiveValue()) : NaN

    if getattribute(m, ResultCount()) &gt; 0
        result_status = getattribute(m, PrimalStatus())
        primal_variable_result = getattribute(m, VariableResult(), x)
        return IntegerLinearResult(termination_status, result_status, primal_variable_result, objvalue, objbound)
    else
        return IntegerLinearResult(termination_status, UnknownResultStatus, Float64[], objvalue, objbound)
    end
end</code></pre><h2><a class="nav-anchor" id="Advanced-1" href="#Advanced-1">Advanced</a></h2><h3><a class="nav-anchor" id="Duals-1" href="#Duals-1">Duals</a></h3><p>Conic duality is the starting point for MOI&#39;s duality conventions. When all functions are affine (or coordinate projections), and all constraint sets are closed convex cone, the instance may be called a conic optimization problem. For conic-form minimization problems, the primal is:</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \max_{y_1, \ldots, y_m} &amp; -\sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 - \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>where each <span>$\mathcal{C}_i$</span> is a closed convex cone and <span>$\mathcal{C}_i^*$</span> is its dual cone.</p><p>For conic-form maximization problems, the primal is:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1, \ldots, y_m} &amp; \sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 + \sum_{i=1}^m A_i^T y_i &amp; = 0
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>A linear inequality constraint <span>$a^T x + b \ge c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_+$</span>, and similarly <span>$a^T x + b \le c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_-$</span>. Variable-wise constraints should be interpreted as affine constraints with the appropriate identity mapping in place of <span>$A_i$</span>.</p><p>For the special case of minimization LPs, the MOI primal form can be stated as</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>By applying the stated transformations to conic form, taking the dual, and transforming back into linear inequality form, one obtains the following dual:</p><div>\[\begin{align}
&amp; \max_{y_1,y_2,y_3} &amp; b_1^Ty_1 + b_2^Ty_2 + b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><p>For maximization LPs, the MOI primal form can be stated as:</p><div>\[\begin{align}
&amp; \max_{x \in \mathbb{R}^n} &amp; a_0^T x &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1 x &amp; \ge b_1\\
&amp;&amp; A_2 x &amp; \le b_2\\
&amp;&amp; A_3 x &amp; = b_3
\end{align}\]</div><p>and similarly, the dual is:</p><div>\[\begin{align}
&amp; \min_{y_1,y_2,y_3} &amp; -b_1^Ty_1 - b_2^Ty_2 - b_3^Ty_3 &amp;+ b_0
\\
&amp; \;\;\text{s.t.}
&amp;A_1^Ty_1 + A_2^Ty_2 + A_3^Ty_3 &amp; = -a_0\\
&amp;&amp; y_1 &amp;\ge 0\\
&amp;&amp; y_2 &amp;\le 0
\end{align}\]</div><p>An important note for the LP case is that the signs of the feasible duals depend only on the sense of the inequality and not on the objective sense.</p><p>Currently, a convention for duals is not defined for problems with non-conic sets <span>$\mathcal{S}_i$</span> or quadratic functions <span>$f_0, f_i$</span>.</p><h3><a class="nav-anchor" id="Modifying-an-instance-1" href="#Modifying-an-instance-1">Modifying an instance</a></h3><p>[Explain <code>modifyconstraint!</code> and <code>modifyobjective!</code>.]</p><h3><a class="nav-anchor" id="Implementing-a-solver-interface-1" href="#Implementing-a-solver-interface-1">Implementing a solver interface</a></h3><p>[The interface is designed for multiple dispatch, e.g., attributes, combinations of sets and functions.]</p><p>[Avoid storing extra copies of the problem when possible.]</p><p>MOI defines a very general interface, with multiple possible ways to describe the same constraint. This is considered a feature, not a bug. MOI is designed to make it possible to experiment with alternative representations of an optimization problem at both the solving and modeling level. When implementing an interface, it is important to keep in mind that the constraints which a solver supports via MOI will have a near 1-to-1 correspondence with how users can express problems in JuMP, because JuMP does not perform automatic transformations. (Alternative systems like Convex.jl do.) For example, if a solver wrapper does not support <code>ScalarAffineFunction</code>-in-<code>LessThan</code> constraints, then users will not be able to write: <code>@constraint(m, 2x + y &lt;= 10)</code> in JuMP. That said, from the perspective of JuMP, solvers can safely choose to not support the following constraints:</p><ul><li><p><code>ScalarAffineFunction</code> in <code>GreaterThan</code>, <code>LessThan</code>, or <code>EqualTo</code> with a nonzero constant in the function. Constants in the affine function should instead be moved into the parameters of the corresponding sets.</p></li><li><p><code>ScalarAffineFunction</code> in <code>Nonnegative</code>, <code>Nonpositive</code> or <code>Zeros</code>. Alternative constraints are available by using a <code>VectorAffineFunction</code> with one output row or <code>ScalarAffineFunction</code> with <code>GreaterThan</code>, <code>LessThan</code>, or <code>EqualTo</code>.</p></li><li><p>Two <code>SingleVariable</code>-in-<code>LessThan</code> constraints applied to the same variable (similarly with <code>GreaterThan</code>). These should be interpreted as variable bounds, and each variable naturally has at most one upper or lower bound.</p></li></ul><p>There is no special interface for column generation. If the solver has a special API for setting coefficients in existing constraints when adding a new variable, it is possible to queue modifications and new variables and then call the solver&#39;s API once all of the new coefficients are known.</p><p>All data passed to the solver should be copied immediately to internal data structures. Solvers may not modify any input vectors and should not assume that input vectors will not be modified by users in the future. This applies, for example, to the coefficient vector in <code>ScalarAffineFunction</code>. Vectors returned to the user, e.g., via <code>ObjectiveFunction</code> or <code>ConstraintFunction</code> attributes should not be modified by the solver afterwards. The in-place version of <code>getattribute!</code> can be used by users to avoid extra copies in this case.</p><p>Solver wrappers should document how the low-level solver statuses map to the MOI statuses. In particular, the characterization of a result with status <code>FeasiblePoint</code> and termination status <code>Success</code> is entirely solver defined. It may or may not be a globally optimal solution. Solver wrappers are not responsible for verifying the feasibility of results. Statuses like <code>NearlyFeasiblePoint</code>, <code>InfeasiblePoint</code>, <code>NearlyInfeasiblePoint</code>, and <code>NearlyReductionCertificate</code> are designed to be used when the solver explicitly indicates as much.</p><p>MOI solver interfaces may be in the same package as the solver itself (either the C wrapper if the solver is accessible through C, or the Julia code if the solver is written in Julia, for example). In some cases it may be more appropriate to host the MOI wrapper in its own package; in this case it is recommended that the MOI wrapper package be named <code>MathOptInterfaceXXX</code> where <code>XXX</code> is the solver name.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="apireference.html"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
