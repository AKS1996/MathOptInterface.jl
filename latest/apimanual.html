<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · MathOptInterface</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptInterface</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="apimanual.html">Manual</a><ul class="internal"><li><a class="toctext" href="#Purpose-1">Purpose</a></li><li><a class="toctext" href="#Standard-form-problem-1">Standard form problem</a></li><li><a class="toctext" href="#Solvers-and-solver-instances-1">Solvers and solver instances</a></li><li><a class="toctext" href="#Variables-1">Variables</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Solving-and-retrieving-the-results-1">Solving and retrieving the results</a></li><li><a class="toctext" href="#A-complete-example:-mixintprog-1">A complete example: <code>mixintprog</code></a></li><li><a class="toctext" href="#Advanced-1">Advanced</a></li></ul></li><li><a class="toctext" href="apireference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apimanual.html">Manual</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/MathOptInterface.jl/tree/9d14a0a0802429d2052d21ee59a4c9bdc08b9ae7/docs/src/apimanual.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h1><h2><a class="nav-anchor" id="Purpose-1" href="#Purpose-1">Purpose</a></h2><p>Each mathematical optimization solver API has its own concepts and data structures for representing optimization instances and obtaining results. However, it is often desirable to represent an instance of an optimization problem at a higher level so that it is easy to try using different solvers. MathOptInterface (MOI) is an abstraction layer designed to provide a unified interface to mathematical optimization solvers so that users do not need to understand multiple solver-specific APIs. MOI can be used directly, or through a higher-level modeling interface like <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a>.</p><p>MOI has been designed to replace <a href="https://github.com/JuliaOpt/MathProgBase.jl">MathProgBase</a>, which has been used by modeling packages such as <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a> and <a href="https://github.com/JuliaOpt/Convex.jl">Convex.jl</a>. This second-generation abstraction layer addresses a number of limitations of MathProgBase. MOI is designed to:</p><ul><li><p>Be simple and extensible, unifying linear, quadratic, and conic optimization, and seamlessly facilitate extensions to essentially arbitrary constraints and functions (e.g., indicator constraints, complementarity constraints, and piecewise linear functions)</p></li><li><p>Be fast by allowing access to a solver&#39;s in-memory representation of a problem without writing intermediate files (when possible) and by using multiple dispatch and concrete types</p></li><li><p>Allow a solver to return multiple results (e.g., a pool of solutions)</p></li><li><p>Allow a solver to return extra arbitrary information via attributes (e.g., variable- and constraint-wise membership in an irreducible inconsistent subset for infeasibility analysis)</p></li><li><p>Provide a greatly expanded set of status codes explaining what happened during the optimization procedure</p></li><li><p>Enable a solver to more precisely specify which problem classes it supports</p></li><li><p>Enable both primal and dual warm starts</p></li><li><p>Enable adding and removing both variables and constraints by using reference objects instead of integer indices</p></li><li><p>Enable any modification that the solver supports to an existing instance</p></li></ul><p>This manual introduces the concepts needed to understand MOI and give a high-level picture of how all of the pieces fit together. The primary focus is on MOI from the perspective of a user of the interface. At the end of the manual we have a section on <a href="apimanual.html#Implementing-a-solver-interface-1">Implementing a solver interface</a>. The reference page lists the complete API.</p><h2><a class="nav-anchor" id="Standard-form-problem-1" href="#Standard-form-problem-1">Standard form problem</a></h2><p>The standard form problem is:</p><div>\[\begin{align}
    &amp; \min_{x \in \mathbb{R}^n} &amp; f_0(x)
    \\
    &amp; \;\;\text{s.t.} &amp; f_i(x) &amp; \in \mathcal{S}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>where:</p><ul><li><p>the functions <span>$f_0, f_1, \ldots, f_m$</span> are specified by <a href="apireference.html#MathOptInterface.AbstractFunction"><code>AbstractFunction</code></a> objects</p></li><li><p>the sets <span>$\mathcal{S}_1, \ldots, \mathcal{S}_m$</span> are specified by <a href="apireference.html#MathOptInterface.AbstractSet"><code>AbstractSet</code></a> objects</p></li></ul><p>The current function types are:</p><ul><li><p><strong>scalar-valued variable-wise</strong>: <span>$x_j$</span>, a scalar variable defined by a variable reference</p></li><li><p><strong>vector-valued variable-wise</strong>: a vector of variables defined by a list of variable references</p></li><li><p><strong>scalar-valued affine</strong>: <span>$a^T x + b$</span>, where <span>$a$</span> is a vector and <span>$b$</span> scalar</p></li><li><p><strong>vector-valued affine</strong>: <span>$A x + b$</span>, where <span>$A$</span> is a matrix and <span>$b$</span> is a vector</p></li><li><p><strong>scalar-valued quadratic</strong>: <span>$\frac{1}{2} x^T Q x + a^T x + b$</span>, where <span>$Q$</span> is a symmetric matrix, <span>$a$</span> is a vector, and <span>$b$</span> is a constant</p></li><li><p><strong>vector-valued quadratic</strong>: a vector of scalar-valued quadratic expressions</p></li></ul><p>In a future version, MOI could be extended to cover functions defined by evaluation oracles (e.g., for nonlinear derivative-based optimization).</p><p>MOI defines some commonly used sets, but the interface is extensible to other sets recognized by the solver. [Describe currently supported sets.]</p><h2><a class="nav-anchor" id="Solvers-and-solver-instances-1" href="#Solvers-and-solver-instances-1">Solvers and solver instances</a></h2><p>Solvers are &quot;factories&quot; used to specify solver-specific parameters and create new instances of a solver API. Solver instances should be understood as the representation of the problem <em>in the solver&#39;s API</em>, just as if one were using its API directly. When possible, the MOI wrapper for a solver should avoid storing an extra copy of the problem data.</p><p>Through the rest of the manual, <code>m</code> is used as a generic solver instance.</p><h2><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h2><p>MOI has a concept of a scalar variable (only). New scalar variables are created with <a href="apireference.html#MathOptInterface.addvariable!"><code>addvariable!</code></a> or <a href="apireference.html#MathOptInterface.addvariables!"><code>addvariables!</code></a>, which return a <a href="apireference.html#MathOptInterface.VariableReference"><code>VariableReference</code></a> or <code>Vector{VariableReference}</code> respectively. Integer indices are never used to reference variables.</p><p>One uses <code>VariableReference</code> objects to set and get variable attributes. For example, the <a href="apireference.html#MathOptInterface.VariablePrimalStart"><code>VariablePrimalStart</code></a> attribute is used to provide an initial starting point for a variable or collection of variables:</p><pre><code class="language-julia">v = addvariable!(m)
setattribute!(m, VariablePrimalStart(), v, 10.5)
v2 = addvariables!(m, 3)
setattribute!(m, VariablePrimalStart(), v2, [1.3,6.8,-4.6])</code></pre><p>A variable can be deleted from a model with <a href="apireference.html#Base.delete!-Tuple{MathOptInterface.AbstractSolverInstance,Union{MathOptInterface.ConstraintReference, MathOptInterface.VariableReference}}"><code>delete!(::AbstractSolverInstance, ::VariableReference)</code></a>, if this functionality is supported by the solver.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><p>MOI defines six functions as listed in the definition of the <a href="apimanual.html#Standard-form-problem-1">Standard form problem</a>. The simplest function is <a href="apireference.html#MathOptInterface.ScalarVariablewiseFunction"><code>ScalarVariablewiseFunction</code></a> defined as:</p><pre><code class="language-julia">struct ScalarVariablewiseFunction &lt;: AbstractFunction
    variable::VariableReference
end</code></pre><p>If <code>v</code> is a <code>VariableReference</code> object, then <code>ScalarVariablewiseFunction(v)</code> is simply the scalar-valued function from the complete set of variables in an instance that returns the value of variable <code>v</code>. This function is useful for defining variablewise constraints.</p><p>A more interesting function is <a href="apireference.html#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>, defined as</p><pre><code class="language-julia">struct ScalarAffineFunction{T} &lt;: AbstractFunction
    varables::Vector{VariableReference}
    coefficients::Vector{T}
    constant::T
end</code></pre><p>If <code>x</code> is a vector of <code>VariableReference</code> objects, then <code>ScalarAffineFunction([x[1],x[2]],[5.0,-2.3],1.0)</code> represents the function <span>$5x_1 - 2.3x_2 + 1$</span>.</p><p>Objective functions are assigned to an instance by calling <a href="apireference.html#MathOptInterface.setobjective!"><code>setobjective!</code></a>. For example,</p><pre><code class="language-julia">x = addvariables!(m, 2)
setobjective!(m, ScalarAffineFunction([x[1],x[2]],[5.0,-2.3],1.0))
setattribute!(m, Sense, MinSense)</code></pre><p>sets the objective to the function just discussed in the minimization sense.</p><p>See <a href="apireference.html#Functions-and-function-modifications-1">Functions and function modifications</a> for the complete list of functions.</p><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>[Examples of sets and how to use them. How to add constraints.]</p><h2><a class="nav-anchor" id="Solving-and-retrieving-the-results-1" href="#Solving-and-retrieving-the-results-1">Solving and retrieving the results</a></h2><p>[Example of calling <code>optimize!</code> and getting the status and results back.]</p><h2><a class="nav-anchor" id="A-complete-example:-mixintprog-1" href="#A-complete-example:-mixintprog-1">A complete example: <code>mixintprog</code></a></h2><p>[Showcase of how to go from data to MOI instance to <code>optimize!</code> to results, by implementing the <code>mixintprog</code> function]</p><h2><a class="nav-anchor" id="Advanced-1" href="#Advanced-1">Advanced</a></h2><h3><a class="nav-anchor" id="Duals-1" href="#Duals-1">Duals</a></h3><p>Currently, a convention for duals is not defined for problems with non-conic sets <span>$\mathcal{S}_i$</span> or quadratic functions <span>$f_0, f_i$</span>. Note that bound constraints are supported by re-interpretation in terms of the nonnegative or nonpositive cones. An affine constraint <span>$a^T x + b \ge c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_+$</span>, and similarly <span>$a^T x + b \le c$</span> should be interpreted as <span>$a^T x + b - c \in \mathbb{R}_-$</span>. Variable-wise constraints should be interpreted as affine constraints with the appropriate identity mapping in place of <span>$A_i$</span>.</p><p>For such conic form minimization problems, the primal is:</p><div>\[\begin{align}
&amp; \min_{x \in \mathbb{R}^n} &amp; a_0^T x + b_0
\\
&amp; \;\;\text{s.t.} &amp; A_i x + b_i &amp; \in \mathcal{C}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>and the dual is:</p><div>\[\begin{align}
&amp; \max_{y_1, \ldots, y_m} &amp; -\sum_{i=1}^m b_i^T y_i + b_0
\\
&amp; \;\;\text{s.t.} &amp; a_0 - \sum_{i=1}^m A_i^T y_i &amp; \in {0}^n
\\
&amp; &amp; y_i &amp; \in \mathcal{C}_i^* &amp; i = 1 \ldots m
\end{align}\]</div><p>where each <span>$\mathcal{C}_i$</span> is a closed convex cone and <span>$\mathcal{C}_i$</span> is its dual cone.</p><p>Note:</p><ul><li><p>lower bounds have nonnegative duals</p></li><li><p>upper bounds have nonpositive duals</p></li><li><p>closed convex cones have duals belonging to the corresponding dual cones</p></li></ul><h3><a class="nav-anchor" id="Modifying-an-instance-1" href="#Modifying-an-instance-1">Modifying an instance</a></h3><p>[Explain <code>modifyconstraint!</code> and <code>modifyobjective!</code>.]</p><h3><a class="nav-anchor" id="Implementing-a-solver-interface-1" href="#Implementing-a-solver-interface-1">Implementing a solver interface</a></h3><p>[Discussion for potential authors of solver interfaces]</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="apireference.html"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
